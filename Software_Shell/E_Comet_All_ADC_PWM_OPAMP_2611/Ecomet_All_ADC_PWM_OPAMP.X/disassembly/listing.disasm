Disassembly Listing for Ecomet_All_ADC_PWM_OPAMP
Generated From:
C:/Users/NapAp/Documents/Ecole/M2/Q1/Projet/Software/E_Comet_All_ADC_PWM_OPAMP/Ecomet_All_ADC_PWM_OPAMP.X/dist/default/debug/Ecomet_All_ADC_PWM_OPAMP.X.debug.elf
24-nov.-2023 14:34:12

---  C:/Users/NapAp/Documents/Ecole/M2/Q1/Projet/Software/E_Comet_All_ADC_PWM_OPAMP/mcc_generated_files/traps.c
1:                 /**
2:                   System Traps Generated Driver File 
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     traps.h
9:                 
10:                  @Summary:
11:                    This is the generated driver implementation file for handling traps
12:                    using PIC24 / dsPIC33 / PIC32MM MCUs
13:                
14:                  @Description:
15:                    This source file provides implementations for PIC24 / dsPIC33 / PIC32MM MCUs traps.
16:                    Generation Information : 
17:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.171.4
18:                        Device            :  dsPIC33CK32MP105
19:                    The generated drivers are tested against the following:
20:                        Compiler          :  XC16 v2.10
21:                        MPLAB             :  MPLAB X v6.05
22:                */
23:                /*
24:                    (c) 2020 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                /**
46:                    Section: Includes
47:                */
48:                #include <xc.h>
49:                #include "traps.h"
50:                
51:                #define ERROR_HANDLER __attribute__((interrupt, no_auto_psv, keep, section("error_handler")))
52:                #define FAILSAFE_STACK_GUARDSIZE 8
53:                
54:                /**
55:                 * a private place to store the error code if we run into a severe error
56:                 */
57:                static uint16_t TRAPS_error_code = -1;
58:                
59:                /**
60:                 * Halts 
61:                 * 
62:                 * @param code error code
63:                 */
64:                void __attribute__((weak)) TRAPS_halt_on_error(uint16_t code)
65:                {
0018DC  FA0002     LNK #0x2
0018DE  780F00     MOV W0, [W14]
66:                    TRAPS_error_code = code;
0018E0  78009E     MOV [W14], W1
0018E2  8883A1     MOV W1, 0x1074
0018E4  DA4000     BREAK
67:                #ifdef __DEBUG    
68:                    __builtin_software_breakpoint();
69:                    /* If we are in debug mode, cause a software breakpoint in the debugger */
70:                #endif
71:                    while(1);
0018E6  37FFFF     BRA .L2
72:                    
73:                }
74:                
75:                /**
76:                 * Sets the stack pointer to a backup area of memory, in case we run into
77:                 * a stack error (in which case we can't really trust the stack pointer)
78:                 */
79:                inline static void use_failsafe_stack(void)
80:                {
0018E8  FA0000     LNK #0x0
81:                    static uint8_t failsafe_stack[32];
82:                    asm volatile (
0018EA  210780     MOV #0x1078, W0
0018EC  780780     MOV W0, W15
83:                        "   mov    %[pstack], W15\n"
84:                        :
85:                        : [pstack]"r"(failsafe_stack)
86:                    );
87:                /* Controls where the stack pointer limit is, relative to the end of the
88:                 * failsafe stack
89:                 */    
90:                    SPLIM = (uint16_t)(((uint8_t *)failsafe_stack) + sizeof(failsafe_stack) 
0018EE  210900     MOV #0x1090, W0
0018F0  880100     MOV W0, SPLIM
91:                            - FAILSAFE_STACK_GUARDSIZE);
92:                }
0018F2  FA8000     ULNK
0018F4  060000     RETURN
93:                
94:                
95:                /** Oscillator Fail Trap vector**/
96:                void ERROR_HANDLER _OscillatorFail(void)
97:                {
0003CA  F80036     PUSH RCOUNT
0003CC  BE9F80     MOV.D W0, [W15++]
0003CE  BE9F82     MOV.D W2, [W15++]
0003D0  BE9F84     MOV.D W4, [W15++]
0003D2  BE9F86     MOV.D W6, [W15++]
0003D4  FA0000     LNK #0x0
98:                    INTCON1bits.OSCFAIL = 0;  //Clear the trap flag
0003D6  A928C0     BCLR INTCON1, #1
99:                    TRAPS_halt_on_error(TRAPS_OSC_FAIL);
0003D8  EB0000     CLR W0
0003DA  070A80     RCALL TRAPS_halt_on_error
100:               }
0003DC  FA8000     ULNK
0003DE  BE034F     MOV.D [--W15], W6
0003E0  BE024F     MOV.D [--W15], W4
0003E2  BE014F     MOV.D [--W15], W2
0003E4  BE004F     MOV.D [--W15], W0
0003E6  F90036     POP RCOUNT
0003E8  064000     RETFIE
101:               /** Stack Error Trap Vector**/
102:               void ERROR_HANDLER _StackError(void)
103:               {
0003EA  F80036     PUSH RCOUNT
0003EC  BE9F80     MOV.D W0, [W15++]
0003EE  BE9F82     MOV.D W2, [W15++]
0003F0  BE9F84     MOV.D W4, [W15++]
0003F2  BE9F86     MOV.D W6, [W15++]
0003F4  FA0000     LNK #0x0
104:                   /* We use a failsafe stack: the presence of a stack-pointer error
105:                    * means that we cannot trust the stack to operate correctly unless
106:                    * we set the stack pointer to a safe place.
107:                    */
108:                   use_failsafe_stack(); 
0003F6  070A78     RCALL _use_failsafe_stack, .LFE0, .LFB1
109:                   INTCON1bits.STKERR = 0;  //Clear the trap flag
0003F8  A948C0     BCLR INTCON1, #2
110:                   TRAPS_halt_on_error(TRAPS_STACK_ERR);
0003FA  200010     MOV #0x1, W0
0003FC  070A6F     RCALL TRAPS_halt_on_error
111:               }
0003FE  FA8000     ULNK
000400  BE034F     MOV.D [--W15], W6
000402  BE024F     MOV.D [--W15], W4
000404  BE014F     MOV.D [--W15], W2
000406  BE004F     MOV.D [--W15], W0
000408  F90036     POP RCOUNT
00040A  064000     RETFIE
112:               /** Address error Trap vector**/
113:               void ERROR_HANDLER _AddressError(void)
114:               {
00040C  F80036     PUSH RCOUNT
00040E  BE9F80     MOV.D W0, [W15++]
000410  BE9F82     MOV.D W2, [W15++]
000412  BE9F84     MOV.D W4, [W15++]
000414  BE9F86     MOV.D W6, [W15++]
000416  FA0000     LNK #0x0
115:                   INTCON1bits.ADDRERR = 0;  //Clear the trap flag
000418  A968C0     BCLR INTCON1, #3
116:                   TRAPS_halt_on_error(TRAPS_ADDRESS_ERR);
00041A  200020     MOV #0x2, W0
00041C  070A5F     RCALL TRAPS_halt_on_error
117:               }
00041E  FA8000     ULNK
000420  BE034F     MOV.D [--W15], W6
000422  BE024F     MOV.D [--W15], W4
000424  BE014F     MOV.D [--W15], W2
000426  BE004F     MOV.D [--W15], W0
000428  F90036     POP RCOUNT
00042A  064000     RETFIE
118:               /** Math Error Trap vector**/
119:               void ERROR_HANDLER _MathError(void)
120:               {
00042C  F80036     PUSH RCOUNT
00042E  BE9F80     MOV.D W0, [W15++]
000430  BE9F82     MOV.D W2, [W15++]
000432  BE9F84     MOV.D W4, [W15++]
000434  BE9F86     MOV.D W6, [W15++]
000436  FA0000     LNK #0x0
121:                   INTCON1bits.MATHERR = 0;  //Clear the trap flag
000438  A988C0     BCLR INTCON1, #4
122:                   TRAPS_halt_on_error(TRAPS_MATH_ERR);
00043A  200030     MOV #0x3, W0
00043C  070A4F     RCALL TRAPS_halt_on_error
123:               }
00043E  FA8000     ULNK
000440  BE034F     MOV.D [--W15], W6
000442  BE024F     MOV.D [--W15], W4
000444  BE014F     MOV.D [--W15], W2
000446  BE004F     MOV.D [--W15], W0
000448  F90036     POP RCOUNT
00044A  064000     RETFIE
124:               /** Generic Hard Trap vector**/
125:               void ERROR_HANDLER _HardTrapError(void)
126:               {
00044C  F80036     PUSH RCOUNT
00044E  BE9F80     MOV.D W0, [W15++]
000450  BE9F82     MOV.D W2, [W15++]
000452  BE9F84     MOV.D W4, [W15++]
000454  BE9F86     MOV.D W6, [W15++]
000456  FA0000     LNK #0x0
127:                   INTCON4bits.SGHT = 0;  //Clear the trap flag
000458  A908C6     BCLR INTCON4, #0
128:                   TRAPS_halt_on_error(TRAPS_HARD_ERR);
00045A  200070     MOV #0x7, W0
00045C  070A3F     RCALL TRAPS_halt_on_error
129:               }
00045E  FA8000     ULNK
000460  BE034F     MOV.D [--W15], W6
000462  BE024F     MOV.D [--W15], W4
000464  BE014F     MOV.D [--W15], W2
000466  BE004F     MOV.D [--W15], W0
000468  F90036     POP RCOUNT
00046A  064000     RETFIE
130:               /** Generic Soft Trap vector**/
131:               void ERROR_HANDLER _SoftTrapError(void)
132:               {
00046C  F80036     PUSH RCOUNT
00046E  BE9F80     MOV.D W0, [W15++]
000470  BE9F82     MOV.D W2, [W15++]
000472  BE9F84     MOV.D W4, [W15++]
000474  BE9F86     MOV.D W6, [W15++]
000476  FA0000     LNK #0x0
133:                   if(INTCON3bits.NAE)
000478  804621     MOV INTCON3, W1
00047A  201000     MOV #0x100, W0
00047C  608000     AND W1, W0, W0
00047E  E00000     CP0 W0
000480  320003     BRA Z, .L10
134:                   {
135:                     INTCON3bits.NAE = 0;  //Clear the trap flag
000482  A908C5     BCLR 0x8C5, #0
136:                     TRAPS_halt_on_error(TRAPS_NVM_ERR);
000484  2000C0     MOV #0xC, W0
000486  070A2A     RCALL TRAPS_halt_on_error
137:                   }
138:               
139:                   if(INTCON3bits.DOOVR)
000488  804620     MOV INTCON3, W0
00048A  600070     AND W0, #0x10, W0
00048C  E00000     CP0 W0
00048E  320003     BRA Z, .L11
140:                   {
141:                     INTCON3bits.DOOVR = 0;  //Clear the trap flag
000490  A988C4     BCLR INTCON3, #4
142:                     TRAPS_halt_on_error(TRAPS_DOOVR_ERR);
000492  2000A0     MOV #0xA, W0
000494  070A23     RCALL TRAPS_halt_on_error
143:                   }
144:               
145:                   if(INTCON3bits.APLL)
000496  804620     MOV INTCON3, W0
000498  600061     AND W0, #0x1, W0
00049A  E00000     CP0 W0
00049C  320003     BRA Z, .L12
146:                   {
147:                     INTCON3bits.APLL = 0;  //Clear the trap flag
00049E  A908C4     BCLR INTCON3, #0
148:                     TRAPS_halt_on_error(TRAPS_APLL_ERR);
0004A0  2000B0     MOV #0xB, W0
0004A2  070A1C     RCALL TRAPS_halt_on_error
149:                   }
150:               
151:                   while(1);
0004A4  37FFFF     BRA .L12
152:               }
153:               
154:               
---  C:/Users/NapAp/Documents/Ecole/M2/Q1/Projet/Software/E_Comet_All_ADC_PWM_OPAMP/mcc_generated_files/system.c
1:                 /**
2:                   @Generated PIC24 / dsPIC33 / PIC32MM MCUs Source File
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     system.h
9:                 
10:                  @Summary:
11:                    This is the sysetm.h file generated using PIC24 / dsPIC33 / PIC32MM MCUs
12:                
13:                  @Description:
14:                    This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                    Generation Information :
16:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.171.4
17:                        Device            :  dsPIC33CK32MP105
18:                    The generated drivers are tested against the following:
19:                        Compiler          :  XC16 v2.10
20:                        MPLAB             :  MPLAB X v6.05
21:                */
22:                
23:                /*
24:                    (c) 2020 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                // Configuration bits: selected in the GUI
46:                
47:                // FSEC
48:                #pragma config BWRP = OFF    //Boot Segment Write-Protect bit->Boot Segment may be written
49:                #pragma config BSS = DISABLED    //Boot Segment Code-Protect Level bits->No Protection (other than BWRP)
50:                #pragma config BSEN = OFF    //Boot Segment Control bit->No Boot Segment
51:                #pragma config GWRP = OFF    //General Segment Write-Protect bit->General Segment may be written
52:                #pragma config GSS = DISABLED    //General Segment Code-Protect Level bits->No Protection (other than GWRP)
53:                #pragma config CWRP = OFF    //Configuration Segment Write-Protect bit->Configuration Segment may be written
54:                #pragma config CSS = DISABLED    //Configuration Segment Code-Protect Level bits->No Protection (other than CWRP)
55:                #pragma config AIVTDIS = OFF    //Alternate Interrupt Vector Table bit->Disabled AIVT
56:                
57:                // FBSLIM
58:                #pragma config BSLIM = 8191    //Boot Segment Flash Page Address Limit bits->8191
59:                
60:                // FOSCSEL
61:                #pragma config FNOSC = FRCDIVN    //Oscillator Source Selection->Internal Fast RC (FRC) Oscillator with postscaler
62:                #pragma config IESO = OFF    //Two-speed Oscillator Start-up Enable bit->Start up with user-selected oscillator source
63:                
64:                // FOSC
65:                #pragma config POSCMD = NONE    //Primary Oscillator Mode Select bits->Primary Oscillator disabled
66:                #pragma config OSCIOFNC = OFF    //OSC2 Pin Function bit->OSC2 is clock output
67:                #pragma config FCKSM = CSDCMD    //Clock Switching Mode bits->Both Clock switching and Fail-safe Clock Monitor are disabled
68:                #pragma config PLLKEN = ON    //PLL Lock Enable->PLL clock output will be disabled if LOCK is lost
69:                #pragma config XTCFG = G3    //XT Config->24-32 MHz crystals
70:                #pragma config XTBST = ENABLE    //XT Boost->Boost the kick-start
71:                
72:                // FWDT
73:                #pragma config RWDTPS = PS2147483648    //Run Mode Watchdog Timer Post Scaler select bits->1:2147483648
74:                #pragma config RCLKSEL = LPRC    //Watchdog Timer Clock Select bits->Always use LPRC
75:                #pragma config WINDIS = OFF    //Watchdog Timer Window Enable bit->Watchdog Timer in Window mode
76:                #pragma config WDTWIN = WIN25    //Watchdog Timer Window Select bits->WDT Window is 25% of WDT period
77:                #pragma config SWDTPS = PS2147483648    //Sleep Mode Watchdog Timer Post Scaler select bits->1:2147483648
78:                #pragma config FWDTEN = ON_SW    //Watchdog Timer Enable bit->WDT controlled via SW, use WDTCON.ON bit
79:                
80:                // FPOR
81:                #pragma config BISTDIS = DISABLED    //Memory BIST Feature Disable->mBIST on reset feature disabled
82:                
83:                // FICD
84:                #pragma config ICS = PGD3    //ICD Communication Channel Select bits->Communicate on PGC1 and PGD1
85:                #pragma config JTAGEN = OFF    //JTAG Enable bit->JTAG is disabled
86:                
87:                // FDMTIVTL
88:                #pragma config DMTIVTL = 0    //Dead Man Timer Interval low word->0
89:                
90:                // FDMTIVTH
91:                #pragma config DMTIVTH = 0    //Dead Man Timer Interval high word->0
92:                
93:                // FDMTCNTL
94:                #pragma config DMTCNTL = 0    //Lower 16 bits of 32 bit DMT instruction count time-out value (0-0xFFFF)->0
95:                
96:                // FDMTCNTH
97:                #pragma config DMTCNTH = 0    //Upper 16 bits of 32 bit DMT instruction count time-out value (0-0xFFFF)->0
98:                
99:                // FDMT
100:               #pragma config DMTDIS = OFF    //Dead Man Timer Disable bit->Dead Man Timer is Disabled and can be enabled by software
101:               
102:               // FDEVOPT
103:               #pragma config ALTI2C1 = OFF    //Alternate I2C1 Pin bit->I2C1 mapped to SDA1/SCL1 pins
104:               #pragma config ALTI2C2 = OFF    //Alternate I2C2 Pin bit->I2C2 mapped to SDA2/SCL2 pins
105:               #pragma config SMB3EN = SMBUS3    //SM Bus Enable->SMBus 3.0 input levels
106:               #pragma config SPI2PIN = PPS    //SPI2 Pin Select bit->SPI2 uses I/O remap (PPS) pins
107:               
108:               // FALTREG
109:               #pragma config CTXT1 = OFF    //Specifies Interrupt Priority Level (IPL) Associated to Alternate Working Register 1 bits->Not Assigned
110:               #pragma config CTXT2 = OFF    //Specifies Interrupt Priority Level (IPL) Associated to Alternate Working Register 2 bits->Not Assigned
111:               #pragma config CTXT3 = OFF    //Specifies Interrupt Priority Level (IPL) Associated to Alternate Working Register 3 bits->Not Assigned
112:               #pragma config CTXT4 = OFF    //Specifies Interrupt Priority Level (IPL) Associated to Alternate Working Register 4 bits->Not Assigned
113:               
114:               #include "pin_manager.h"
115:               #include "clock.h"
116:               #include "system.h"
117:               #include "system_types.h"
118:               #include "opa.h"
119:               #include "pwm.h"
120:               #include "adc1.h"
121:               #include "mccp5_capture.h"
122:               #include "interrupt_manager.h"
123:               #include "traps.h"
124:               
125:               void SYSTEM_Initialize(void)
126:               {
001854  FA0000     LNK #0x0
127:                   PIN_MANAGER_Initialize();
001856  07FFA1     RCALL PIN_MANAGER_Initialize
128:                   CLOCK_Initialize();
001858  07FF6A     RCALL CLOCK_Initialize
129:                   INTERRUPT_Initialize();
00185A  070020     RCALL INTERRUPT_Initialize
130:                   MCCP5_CAPTURE_Initialize();
00185C  07FF14     RCALL MCCP5_CAPTURE_Initialize
131:                   OPA_Initialize();
00185E  07004F     RCALL OPA_Initialize
132:                   ADC1_Initialize();
001860  07FCC2     RCALL ADC1_Initialize
133:                   PWM_Initialize();
001862  07FDCA     RCALL PWM_Initialize
134:                   INTERRUPT_GlobalEnable();
001864  07FFF1     RCALL _INTERRUPT_GlobalEnable, .LFE1, .LFB90
135:                   SYSTEM_CORCONModeOperatingSet(CORCON_MODE_PORVALUES);
001866  200200     MOV #0x20, W0
001868  07FFE6     RCALL .Letext0, .LFE99, _SYSTEM_CORCONModeOperatingSet, .Ltext0, .LFB1
136:               }
00186A  FA8000     ULNK
00186C  060000     RETURN
137:               
138:               /**
139:                End of File
140:               */
---  C:/Users/NapAp/Documents/Ecole/M2/Q1/Projet/Software/E_Comet_All_ADC_PWM_OPAMP/mcc_generated_files/reset.c
1:                 /**
2:                   RESET Generated Driver File
3:                 
4:                   @Company
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name
8:                     reset.c
9:                 
10:                  @Summary
11:                    This is the generated driver implementation file for the RESET driver using PIC24 / dsPIC33 / PIC32MM MCUs
12:                
13:                  @Description
14:                    This header file provides implementations for driver APIs for RESET.
15:                    Generation Information :
16:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.171.4
17:                        Device            :  dsPIC33CK32MP105
18:                    The generated drivers are tested against the following:
19:                        Compiler          :  XC16 v2.10
20:                        MPLAB             :  MPLAB X v6.05
21:                */
22:                
23:                /*
24:                    (c) 2020 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                #include <stdbool.h>
46:                #include <stdint.h>
47:                #include "xc.h"
48:                #include "reset.h"
49:                
50:                /**
51:                 Section: Local Variables
52:                */
53:                
54:                /**
55:                 Section: Function prototypes
56:                */
57:                static bool RESET_CauseFromSoftware(uint16_t resetCause);
58:                static bool RESET_CauseFromWatchdogTimer(uint16_t resetCause);
59:                static bool RESET_CauseFromConfigurationMismatch(uint16_t resetCause);
60:                static bool RESET_CauseFromIllegalOpcode(uint16_t resetCause);
61:                static bool RESET_CauseFromExternal(uint16_t resetCause);
62:                static bool RESET_CauseFromTrap(uint16_t resetCause);
63:                static void RESET_CauseClear(RESET_MASKS resetFlagMask);
64:                
65:                uint16_t RESET_GetCause(void)
66:                {
001572  FA0000     LNK #0x0
67:                    return RCON;
001574  807C00     MOV RCON, W0
68:                }
001576  FA8000     ULNK
001578  060000     RETURN
69:                
70:                void __attribute__ ((weak)) RESET_CauseHandler(void)
71:                {
00157A  FA0002     LNK #0x2
72:                    uint16_t resetCause = RESET_GetCause();
00157C  07FFFA     RCALL RESET_GetCause
00157E  780F00     MOV W0, [W14]
73:                    if(RESET_CauseFromTrap(resetCause))
001580  78001E     MOV [W14], W0
001582  070024     RCALL _RESET_CauseFromTrap, .LFE1, .LFB2
001584  E00400     CP0.B W0
001586  320002     BRA Z, .L3
74:                    { 
75:                      RESET_CauseClear(RESET_MASK_TRAPR); 
001588  280000     MOV #0x8000, W0
00158A  070071     RCALL _RESET_CauseClear, .LFE7, .LFB8
76:                      //Do something 
77:                    }
78:                    if(RESET_CauseFromIllegalOpcode(resetCause))
00158C  78001E     MOV [W14], W0
00158E  07002A     RCALL _RESET_CauseFromIllegalOpcode, .LFE2, .LFB3
001590  E00400     CP0.B W0
001592  320002     BRA Z, .L4
79:                    { 
80:                      RESET_CauseClear(RESET_MASK_IOPUWR); 
001594  240000     MOV #0x4000, W0
001596  07006B     RCALL _RESET_CauseClear, .LFE7, .LFB8
81:                      //Do something 
82:                    }
83:                    if(RESET_CauseFromConfigurationMismatch(resetCause))
001598  78001E     MOV [W14], W0
00159A  070032     RCALL _RESET_CauseFromConfigurationMismatch, .LFE3, .LFB4
00159C  E00400     CP0.B W0
00159E  320002     BRA Z, .L5
84:                    { 
85:                      RESET_CauseClear(RESET_MASK_CM); 
0015A0  202000     MOV #0x200, W0
0015A2  070065     RCALL _RESET_CauseClear, .LFE7, .LFB8
86:                      //Do something 
87:                    }
88:                    if(RESET_CauseFromExternal(resetCause))
0015A4  78001E     MOV [W14], W0
0015A6  07003A     RCALL _RESET_CauseFromExternal, .LFE4, .LFB5
0015A8  E00400     CP0.B W0
0015AA  320002     BRA Z, .L6
89:                    { 
90:                      RESET_CauseClear(RESET_MASK_EXTR); 
0015AC  200800     MOV #0x80, W0
0015AE  07005F     RCALL _RESET_CauseClear, .LFE7, .LFB8
91:                      //Do something 
92:                    }
93:                    if(RESET_CauseFromSoftware(resetCause))
0015B0  78001E     MOV [W14], W0
0015B2  070042     RCALL _RESET_CauseFromSoftware, .LFE5, .LFB6
0015B4  E00400     CP0.B W0
0015B6  320002     BRA Z, .L7
94:                    { 
95:                      RESET_CauseClear(RESET_MASK_SWR); 
0015B8  200400     MOV #0x40, W0
0015BA  070059     RCALL _RESET_CauseClear, .LFE7, .LFB8
96:                      //Do something 
97:                    }
98:                    if(RESET_CauseFromWatchdogTimer(resetCause))
0015BC  78001E     MOV [W14], W0
0015BE  07004A     RCALL _RESET_CauseFromWatchdogTimer, .LFE6, .LFB7
0015C0  E00400     CP0.B W0
0015C2  320002     BRA Z, .L2
99:                    { 
100:                     RESET_CauseClear(RESET_MASK_WDTO); 
0015C4  200100     MOV #0x10, W0
0015C6  070053     RCALL _RESET_CauseClear, .LFE7, .LFB8
101:                     //Do something 
102:                   }
103:               }
0015C8  FA8000     ULNK
0015CA  060000     RETURN
104:               
105:               static bool RESET_CauseFromTrap(uint16_t resetCause)
106:               {
0015CC  FA0004     LNK #0x4
0015CE  980710     MOV W0, [W14+2]
107:                   bool resetStatus = false;
0015D0  EB4000     CLR.B W0
0015D2  784F00     MOV.B W0, [W14]
108:                   if(resetCause & RESET_MASK_TRAPR)
0015D4  90001E     MOV [W14+2], W0
0015D6  E00000     CP0 W0
0015D8  3D0002     BRA GE, .L10
109:                   { 
110:                     resetStatus = true; 
0015DA  B3C010     MOV.B #0x1, W0
0015DC  784F00     MOV.B W0, [W14]
111:                   }
112:                   return resetStatus;
0015DE  78401E     MOV.B [W14], W0
113:               }
0015E0  FA8000     ULNK
0015E2  060000     RETURN
114:               
115:               static bool RESET_CauseFromIllegalOpcode(uint16_t resetCause)
116:               {
0015E4  FA0004     LNK #0x4
0015E6  980710     MOV W0, [W14+2]
117:                   bool resetStatus = false;
0015E8  EB4000     CLR.B W0
0015EA  784F00     MOV.B W0, [W14]
118:                   if(resetCause & RESET_MASK_IOPUWR)
0015EC  90009E     MOV [W14+2], W1
0015EE  240000     MOV #0x4000, W0
0015F0  608000     AND W1, W0, W0
0015F2  E00000     CP0 W0
0015F4  320002     BRA Z, .L12
119:                   { 
120:                     resetStatus = true; 
0015F6  B3C010     MOV.B #0x1, W0
0015F8  784F00     MOV.B W0, [W14]
121:                   }
122:                   return resetStatus;
0015FA  78401E     MOV.B [W14], W0
123:               }
0015FC  FA8000     ULNK
0015FE  060000     RETURN
124:               
125:               static bool RESET_CauseFromConfigurationMismatch(uint16_t resetCause)
126:               {
001600  FA0004     LNK #0x4
001602  980710     MOV W0, [W14+2]
127:                   bool resetStatus = false;
001604  EB4000     CLR.B W0
001606  784F00     MOV.B W0, [W14]
128:                   if(resetCause & RESET_MASK_CM)
001608  90009E     MOV [W14+2], W1
00160A  202000     MOV #0x200, W0
00160C  608000     AND W1, W0, W0
00160E  E00000     CP0 W0
001610  320002     BRA Z, .L14
129:                   { 
130:                     resetStatus = true; 
001612  B3C010     MOV.B #0x1, W0
001614  784F00     MOV.B W0, [W14]
131:                   }
132:                   return resetStatus;
001616  78401E     MOV.B [W14], W0
133:               }
001618  FA8000     ULNK
00161A  060000     RETURN
134:               
135:               static bool RESET_CauseFromExternal(uint16_t resetCause)
136:               {
00161C  FA0004     LNK #0x4
00161E  980710     MOV W0, [W14+2]
137:                   bool resetStatus = false;
001620  EB4000     CLR.B W0
001622  784F00     MOV.B W0, [W14]
138:                   if(resetCause & RESET_MASK_EXTR)
001624  90009E     MOV [W14+2], W1
001626  200800     MOV #0x80, W0
001628  608000     AND W1, W0, W0
00162A  E00000     CP0 W0
00162C  320002     BRA Z, .L16
139:                   { 
140:                     resetStatus = true; 
00162E  B3C010     MOV.B #0x1, W0
001630  784F00     MOV.B W0, [W14]
141:                   }
142:                   return resetStatus;
001632  78401E     MOV.B [W14], W0
143:               }
001634  FA8000     ULNK
001636  060000     RETURN
144:               
145:               static bool RESET_CauseFromSoftware(uint16_t resetCause)
146:               {
001638  FA0004     LNK #0x4
00163A  980710     MOV W0, [W14+2]
147:                   bool resetStatus = false;
00163C  EB4000     CLR.B W0
00163E  784F00     MOV.B W0, [W14]
148:                   if(resetCause & RESET_MASK_SWR)
001640  90009E     MOV [W14+2], W1
001642  200400     MOV #0x40, W0
001644  608000     AND W1, W0, W0
001646  E00000     CP0 W0
001648  320002     BRA Z, .L18
149:                   { 
150:                     resetStatus = true; 
00164A  B3C010     MOV.B #0x1, W0
00164C  784F00     MOV.B W0, [W14]
151:                   }
152:                   return resetStatus;
00164E  78401E     MOV.B [W14], W0
153:               }
001650  FA8000     ULNK
001652  060000     RETURN
154:               
155:               static bool RESET_CauseFromWatchdogTimer(uint16_t resetCause)
156:               {
001654  FA0004     LNK #0x4
001656  980710     MOV W0, [W14+2]
157:                   bool resetStatus = false;
001658  EB4000     CLR.B W0
00165A  784F00     MOV.B W0, [W14]
158:                   if(resetCause & RESET_MASK_WDTO)
00165C  90001E     MOV [W14+2], W0
00165E  600070     AND W0, #0x10, W0
001660  E00000     CP0 W0
001662  320002     BRA Z, .L20
159:                   { 
160:                     resetStatus = true;
001664  B3C010     MOV.B #0x1, W0
001666  784F00     MOV.B W0, [W14]
161:                   }
162:                   return resetStatus;
001668  78401E     MOV.B [W14], W0
163:               }
00166A  FA8000     ULNK
00166C  060000     RETURN
164:               
165:               static void RESET_CauseClear(RESET_MASKS resetFlagMask)
166:               { 
00166E  FA0002     LNK #0x2
001670  780F00     MOV W0, [W14]
167:                    RCON = RCON & (~resetFlagMask); 
001672  EA809E     COM [W14], W1
001674  807C00     MOV RCON, W0
001676  608000     AND W1, W0, W0
001678  887C00     MOV W0, RCON
168:               } 
00167A  FA8000     ULNK
00167C  060000     RETURN
169:               
170:               void RESET_CauseClearAll()
171:               { 
00167E  FA0000     LNK #0x0
172:                   RCON = 0x00; 
001680  EF2F80     CLR RCON
173:               }
001682  FA8000     ULNK
001684  060000     RETURN
174:               /**
175:                End of File
176:               */
---  C:/Users/NapAp/Documents/Ecole/M2/Q1/Projet/Software/E_Comet_All_ADC_PWM_OPAMP/mcc_generated_files/pwm.c
1:                 /**
2:                   PWM Generated Driver File
3:                 
4:                   @Company
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name
8:                     pwm.c
9:                 
10:                  @Summary
11:                    This is the generated driver implementation file for the PWM driver using PIC24 / dsPIC33 / PIC32MM MCUs
12:                
13:                  @Description
14:                    This source file provides APIs for PWM.
15:                    Generation Information :
16:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.171.4
17:                        Device            :  dsPIC33CK32MP105
18:                    The generated drivers are tested against the following:
19:                        Compiler          :  XC16 v2.10
20:                        MPLAB 	          :  MPLAB X v6.05
21:                */
22:                
23:                /*
24:                    (c) 2020 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                /**
46:                  Section: Included Files
47:                */
48:                
49:                #include "pwm.h"
50:                
51:                /**
52:                 Section: Driver Interface Function Definitions
53:                */
54:                
55:                void PWM_Initialize (void)
56:                {
0013F8  FA0000     LNK #0x0
57:                    // HREN disabled; MODSEL Independent Edge; TRGCNT 1; CLKSEL Master clock divided by clock divider circuit; ON enabled; 
58:                    PG1CONL = 0x10;
0013FA  200100     MOV #0x10, W0
0013FC  881950     MOV W0, PG1CONL
59:                    // HREN disabled; MODSEL Independent Edge; TRGCNT 1; CLKSEL Master clock divided by clock divider circuit; ON enabled; 
60:                    PG3CONL = 0x10;
0013FE  200100     MOV #0x10, W0
001400  881CB0     MOV W0, PG3CONL
61:                    // MCLKSEL FOSC - System Clock; HRERR disabled; LOCK disabled; DIVSEL 1:2; 
62:                    PCLKCON = 0x00;
001402  EF2300     CLR PCLKCON
63:                    // FSCL 0; 
64:                    FSCL = 0x00;
001404  EF2302     CLR FSCL
65:                    // FSMINPER 0; 
66:                    FSMINPER = 0x00;
001406  EF2304     CLR FSMINPER
67:                    // MPHASE 0; 
68:                    MPHASE = 0x00;
001408  EF2306     CLR MPHASE
69:                    // MDC 0; 
70:                    MDC = 0x00;
00140A  EF2308     CLR MDC
71:                    // MPER 16; 
72:                    MPER = 0x10;
00140C  200100     MOV #0x10, W0
00140E  881850     MOV W0, MPER
73:                    // LFSR 0; 
74:                    LFSR = 0x00;
001410  EF230C     CLR LFSR
75:                    // CTA1EN disabled; CTA2EN disabled; CTA3EN disabled; CTA4EN disabled; 
76:                    CMBTRIGL = 0x00;
001412  EF230E     CLR CMBTRIGL
77:                    // CTB3EN disabled; CTB2EN disabled; CTB1EN disabled; CTB4EN disabled; 
78:                    CMBTRIGH = 0x00;
001414  EF2310     CLR CMBTRIGH
79:                    // PWMLFA PWMS1 or PWMS2;; S1APOL Positive logic; S2APOL Positive logic; PWMLFAD No Assignment; PWMS1A PWM1H; PWMS2A PWM1H; 
80:                    LOGCONA = 0x00;
001416  EF2312     CLR LOGCONA
81:                    // PWMLFB PWMS1 | PWMS2; S2BPOL Positive logic; PWMLFBD No Assignment; S1BPOL Positive logic; PWMS2B PWM1H; PWMS1B PWM1H; 
82:                    LOGCONB = 0x00;
001418  EF2314     CLR LOGCONB
83:                    // PWMLFC PWMS1 | PWMS2; PWMLFCD No Assignment; S2CPOL Positive logic; S1CPOL Positive logic; PWMS1C PWM1H; PWMS2C PWM1H; 
84:                    LOGCONC = 0x00;
00141A  EF2316     CLR LOGCONC
85:                    // PWMS1D PWM1H; S1DPOL Positive logic; PWMLFD PWMS1 | PWMS2; PWMLFDD No Assignment; S2DPOL Positive logic; PWMS2D PWM1H; 
86:                    LOGCOND = 0x00;
00141C  EF2318     CLR LOGCOND
87:                    // PWMS1E PWM1H; PWMS2E PWM1H; S1EPOL Positive logic; PWMLFE PWMS1 | PWMS2; S2EPOL Positive logic; PWMLFED No Assignment; 
88:                    LOGCONE = 0x00;
00141E  EF231A     CLR LOGCONE
89:                    // S1FPOL Positive logic; PWMS2F PWM1H; PWMS1F PWM1H; S2FPOL Positive logic; PWMLFFD No Assignment; PWMLFF PWMS1 | PWMS2; 
90:                    LOGCONF = 0x00;
001420  EF231C     CLR LOGCONF
91:                    // EVTASEL PGTRGSEL bits; EVTASYNC Not synchronized; EVTAPOL Active-high; EVTAPGS PG1; EVTASTRD Stretched to 8 PWM clock cycles minimum; EVTAOEN disabled; 
92:                    PWMEVTA = 0x00;
001422  EF231E     CLR PWMEVTA
93:                    // EVTBPGS PG1; EVTBSYNC Not synchronized; EVTBPOL Active-high; EVTBSEL PGTRGSEL bits; EVTBSTRD Stretched to 8 PWM clock cycles minimum; EVTBOEN disabled; 
94:                    PWMEVTB = 0x00;
001424  EF2320     CLR PWMEVTB
95:                    // EVTCPGS PG1; EVTCPOL Active-high; EVTCSEL PGTRGSEL bits; EVTCSTRD Stretched to 8 PWM clock cycles minimum; EVTCSYNC Not synchronized; EVTCOEN disabled; 
96:                    PWMEVTC = 0x00;
001426  EF2322     CLR PWMEVTC
97:                    // EVTDOEN disabled; EVTDSTRD Stretched to 8 PWM clock cycles minimum; EVTDPOL Active-high; EVTDPGS PG1; EVTDSEL PGTRGSEL bits; EVTDSYNC Not synchronized; 
98:                    PWMEVTD = 0x00;
001428  EF2324     CLR PWMEVTD
99:                    // EVTEOEN disabled; EVTEPOL Active-high; EVTEPGS PG1; EVTESTRD Stretched to 8 PWM clock cycles minimum; EVTESEL PGTRGSEL bits; EVTESYNC Not synchronized; 
100:                   PWMEVTE = 0x00;
00142A  EF2326     CLR PWMEVTE
101:                   // EVTFPOL Active-high; EVTFPGS PG1; EVTFSTRD Stretched to 8 PWM clock cycles minimum; EVTFSEL PGTRGSEL bits; EVTFOEN disabled; EVTFSYNC Not synchronized; 
102:                   PWMEVTF = 0x00;
00142C  EF2328     CLR PWMEVTF
103:                   // MSTEN disabled; TRGMOD Single trigger mode; SOCS Self-trigger; UPDMOD SOC update; MPHSEL disabled; MPERSEL disabled; MDCSEL disabled; 
104:                   PG1CONH = 0x00;
00142E  EF232C     CLR PG1CONH
105:                   // MSTEN disabled; TRGMOD Single trigger mode; SOCS Self-trigger; UPDMOD SOC update; MPHSEL disabled; MPERSEL disabled; MDCSEL disabled; 
106:                   PG3CONH = 0x00;
001430  EF2398     CLR PG3CONH
107:                   // TRSET disabled; UPDREQ disabled; CLEVT disabled; TRCLR disabled; CAP disabled; SEVT disabled; FFEVT disabled; UPDATE disabled; FLTEVT disabled; 
108:                   PG1STAT = 0x00;
001432  EF232E     CLR PG1STAT
109:                   // TRSET disabled; UPDREQ disabled; CLEVT disabled; TRCLR disabled; CAP disabled; SEVT disabled; FFEVT disabled; UPDATE disabled; FLTEVT disabled; 
110:                   PG3STAT = 0x00;
001434  EF239A     CLR PG3STAT
111:                   // FLTDAT 0; DBDAT 0; SWAP disabled; OVRENH disabled; OVRENL disabled; OSYNC User output overrides are synchronized to the local PWM time base; CLMOD disabled; FFDAT 0; CLDAT 0; OVRDAT 0; 
112:                   PG1IOCONL = 0x00;
001436  EF2330     CLR PG1IOCONL
113:                   // FLTDAT 0; DBDAT 0; SWAP disabled; OVRENH disabled; OVRENL disabled; OSYNC User output overrides are synchronized to the local PWM time base; CLMOD disabled; FFDAT 0; CLDAT 0; OVRDAT 0; 
114:                   PG3IOCONL = 0x00;
001438  EF239C     CLR PG3IOCONL
115:                   // PENL enabled; DTCMPSEL PCI Sync Logic; PMOD Complementary; POLL Active-high; PENH enabled; CAPSRC Software; POLH Active-high; 
116:                   PG1IOCONH = 0x0C;
00143A  2000C0     MOV #0xC, W0
00143C  881990     MOV W0, PG1IOCONH
117:                   // PENL enabled; DTCMPSEL PCI Sync Logic; PMOD Complementary; POLL Active-high; PENH enabled; CAPSRC Software; POLH Active-high; 
118:                   PG3IOCONH = 0x0C;
00143E  2000C0     MOV #0xC, W0
001440  881CF0     MOV W0, PG3IOCONH
119:                   // UPDTRG Manual; ADTR1PS 1:1; PGTRGSEL EOC event; ADTR1EN3 disabled; ADTR1EN1 disabled; ADTR1EN2 disabled; 
120:                   PG1EVTL = 0x00;
001442  EF2334     CLR PG1EVTL
121:                   // UPDTRG Manual; ADTR1PS 1:1; PGTRGSEL EOC event; ADTR1EN3 disabled; ADTR1EN1 disabled; ADTR1EN2 disabled; 
122:                   PG3EVTL = 0x00;
001444  EF23A0     CLR PG3EVTL
123:                   // ADTR2EN1 disabled; IEVTSEL EOC; SIEN disabled; FFIEN disabled; ADTR1OFS None; CLIEN disabled; FLTIEN disabled; ADTR2EN2 disabled; ADTR2EN3 disabled; 
124:                   PG1EVTH = 0x00;
001446  EF2336     CLR PG1EVTH
125:                   // ADTR2EN1 disabled; IEVTSEL EOC; SIEN disabled; FFIEN disabled; ADTR1OFS None; CLIEN disabled; FLTIEN disabled; ADTR2EN2 disabled; ADTR2EN3 disabled; 
126:                   PG3EVTH = 0x00;
001448  EF23A2     CLR PG3EVTH
127:                   // PSS Tied to 0; PPS Not inverted; SWTERM disabled; PSYNC disabled; TERM Manual Terminate; AQPS Not inverted; AQSS None; TSYNCDIS PWM EOC; 
128:                   PG1FPCIL = 0x00;
00144A  EF2338     CLR PG1FPCIL
129:                   // PSS Tied to 0; PPS Not inverted; SWTERM disabled; PSYNC disabled; TERM Manual Terminate; AQPS Not inverted; AQSS None; TSYNCDIS PWM EOC; 
130:                   PG3FPCIL = 0x00;
00144C  EF23A4     CLR PG3FPCIL
131:                   // TQPS Not inverted; LATMOD disabled; SWPCI Drives '0'; BPEN disabled; TQSS None; SWPCIM PCI acceptance logic; BPSEL PWM Generator 1; ACP Level-sensitive; 
132:                   PG1FPCIH = 0x00;
00144E  EF233A     CLR PG1FPCIH
133:                   // TQPS Not inverted; LATMOD disabled; SWPCI Drives '0'; BPEN disabled; TQSS None; SWPCIM PCI acceptance logic; BPSEL PWM Generator 1; ACP Level-sensitive; 
134:                   PG3FPCIH = 0x00;
001450  EF23A6     CLR PG3FPCIH
135:                   // PSS Tied to 0; PPS Not inverted; SWTERM disabled; PSYNC disabled; TERM Manual Terminate; AQPS Not inverted; AQSS None; TSYNCDIS PWM EOC; 
136:                   PG1CLPCIL = 0x00;
001452  EF233C     CLR PG1CLPCIL
137:                   // PSS Tied to 0; PPS Not inverted; SWTERM disabled; PSYNC disabled; TERM Manual Terminate; AQPS Not inverted; AQSS None; TSYNCDIS PWM EOC; 
138:                   PG3CLPCIL = 0x00;
001454  EF23A8     CLR PG3CLPCIL
139:                   // PCIGT disabled; TQPS Not inverted; SWPCI Drives '0'; BPEN disabled; TQSS None; SWPCIM PCI acceptance logic; BPSEL PWM Generator 1; ACP Level-sensitive; 
140:                   PG1CLPCIH = 0x00;
001456  EF233E     CLR PG1CLPCIH
141:                   // PCIGT disabled; TQPS Not inverted; SWPCI Drives '0'; BPEN disabled; TQSS None; SWPCIM PCI acceptance logic; BPSEL PWM Generator 1; ACP Level-sensitive; 
142:                   PG3CLPCIH = 0x00;
001458  EF23AA     CLR PG3CLPCIH
143:                   // PSS Tied to 0; PPS Not inverted; SWTERM disabled; PSYNC disabled; TERM Manual Terminate; AQPS Not inverted; AQSS None; TSYNCDIS PWM EOC; 
144:                   PG1FFPCIL = 0x00;
00145A  EF2340     CLR PG1FFPCIL
145:                   // PSS Tied to 0; PPS Not inverted; SWTERM disabled; PSYNC disabled; TERM Manual Terminate; AQPS Not inverted; AQSS None; TSYNCDIS PWM EOC; 
146:                   PG3FFPCIL = 0x00;
00145C  EF23AC     CLR PG3FFPCIL
147:                   // PCIGT disabled; TQPS Not inverted; SWPCI Drives '0'; BPEN disabled; TQSS None; SWPCIM PCI acceptance logic; BPSEL PWM Generator 1; ACP Level-sensitive; 
148:                   PG1FFPCIH = 0x00;
00145E  EF2342     CLR PG1FFPCIH
149:                   // PCIGT disabled; TQPS Not inverted; SWPCI Drives '0'; BPEN disabled; TQSS None; SWPCIM PCI acceptance logic; BPSEL PWM Generator 1; ACP Level-sensitive; 
150:                   PG3FFPCIH = 0x00;
001460  EF23AE     CLR PG3FFPCIH
151:                   // PSS Tied to 0; PPS Not inverted; SWTERM disabled; PSYNC disabled; TERM Manual Terminate; AQPS Not inverted; AQSS None; TSYNCDIS PWM EOC; 
152:                   PG1SPCIL = 0x00;
001462  EF2344     CLR PG1SPCIL
153:                   // PSS Tied to 0; PPS Not inverted; SWTERM disabled; PSYNC disabled; TERM Manual Terminate; AQPS Not inverted; AQSS None; TSYNCDIS PWM EOC; 
154:                   PG3SPCIL = 0x00;
001464  EF23B0     CLR PG3SPCIL
155:                   // PCIGT disabled; TQPS Not inverted; SWPCI Drives '0'; BPEN disabled; TQSS None; SWPCIM PCI acceptance logic; BPSEL PWM Generator 1; ACP Level-sensitive; 
156:                   PG1SPCIH = 0x00;
001466  EF2346     CLR PG1SPCIH
157:                   // PCIGT disabled; TQPS Not inverted; SWPCI Drives '0'; BPEN disabled; TQSS None; SWPCIM PCI acceptance logic; BPSEL PWM Generator 1; ACP Level-sensitive; 
158:                   PG3SPCIH = 0x00;
001468  EF23B2     CLR PG3SPCIH
159:                   // LEB 0; 
160:                   PG1LEBL = 0x00;
00146A  EF2348     CLR PG1LEBL
161:                   // LEB 0; 
162:                   PG3LEBL = 0x00;
00146C  EF23B4     CLR PG3LEBL
163:                   // PWMPCI PWM1; PLR disabled; PLF disabled; PHR disabled; PHF disabled; 
164:                   PG1LEBH = 0x00;
00146E  EF234A     CLR PG1LEBH
165:                   // PWMPCI PWM1; PLR disabled; PLF disabled; PHR disabled; PHF disabled; 
166:                   PG3LEBH = 0x00;
001470  EF23B6     CLR PG3LEBH
167:                   // PHASE 0; 
168:                   PG1PHASE = 0x00;
001472  EF234C     CLR PG1PHASE
169:                   // PHASE 0; 
170:                   PG3PHASE = 0x00;
001474  EF23B8     CLR PG3PHASE
171:                   // DC 0; 
172:                   PG1DC = 0x00;
001476  EF234E     CLR PG1DC
173:                   // DC 625; 
174:                   PG3DC = 0x271;
001478  202710     MOV #0x271, W0
00147A  881DD0     MOV W0, PG3DC
175:                   // DCA 0; 
176:                   PG1DCA = 0x00;
00147C  EF2350     CLR PG1DCA
177:                   // DCA 0; 
178:                   PG3DCA = 0x00;
00147E  EF23BC     CLR PG3DCA
179:                   // PER 199; 
180:                   PG1PER = 0xC7;
001480  200C70     MOV #0xC7, W0
001482  881A90     MOV W0, PG1PER
181:                   // PER 1249; 
182:                   PG3PER = 0x4E1;
001484  204E10     MOV #0x4E1, W0
001486  881DF0     MOV W0, PG3PER
183:                   // TRIGA 0; 
184:                   PG1TRIGA = 0x00;
001488  EF2354     CLR PG1TRIGA
185:                   // TRIGA 0; 
186:                   PG3TRIGA = 0x00;
00148A  EF23C0     CLR PG3TRIGA
187:                   // TRIGB 0; 
188:                   PG1TRIGB = 0x00;
00148C  EF2356     CLR PG1TRIGB
189:                   // TRIGB 0; 
190:                   PG3TRIGB = 0x00;
00148E  EF23C2     CLR PG3TRIGB
191:                   // TRIGC 0; 
192:                   PG1TRIGC = 0x00;
001490  EF2358     CLR PG1TRIGC
193:                   // TRIGC 0; 
194:                   PG3TRIGC = 0x00;
001492  EF23C4     CLR PG3TRIGC
195:                   // DTL 0; 
196:                   PG1DTL = 0x00;
001494  EF235A     CLR PG1DTL
197:                   // DTL 0; 
198:                   PG3DTL = 0x00;
001496  EF23C6     CLR PG3DTL
199:                   // DTH 0; 
200:                   PG1DTH = 0x00;
001498  EF235C     CLR PG1DTH
201:                   // DTH 0; 
202:                   PG3DTH = 0x00;
00149A  EF23C8     CLR PG3DTH
203:                   
204:                   PG1CONLbits.ON = 1;
00149C  A8E32B     BSET 0x32B, #7
205:                   PG3CONLbits.ON = 1;
00149E  A8E397     BSET 0x397, #7
206:               }
0014A0  FA8000     ULNK
0014A2  060000     RETURN
207:               
208:               void __attribute__ ((weak)) PWM_Generator1_CallBack(void)
209:               {
0014A4  FA0000     LNK #0x0
210:                   // Add Application code here
211:               }
0014A6  FA8000     ULNK
0014A8  060000     RETURN
212:               
213:               void PWM_Generator1_Tasks(void)
214:               {
0014AA  FA0000     LNK #0x0
215:                   if(IFS4bits.PWM1IF)
0014AC  804040     MOV IFS4, W0
0014AE  600068     AND W0, #0x8, W0
0014B0  E00000     CP0 W0
0014B2  320002     BRA Z, .L3
216:                   {
217:                       // PWM Generator1 callback function 
218:                       PWM_Generator1_CallBack();
0014B4  07FFF7     RCALL PWM_Generator1_CallBack
219:               
220:                       // clear the PWM Generator1 interrupt flag
221:                       IFS4bits.PWM1IF = 0;
0014B6  A96808     BCLR IFS4, #3
222:                   }
223:               }
0014B8  FA8000     ULNK
0014BA  060000     RETURN
224:               
225:               void __attribute__ ((weak)) PWM_Generator3_CallBack(void)
226:               {
0014BC  FA0000     LNK #0x0
227:                   // Add Application code here
228:               }
0014BE  FA8000     ULNK
0014C0  060000     RETURN
229:               
230:               void PWM_Generator3_Tasks(void)
231:               {
0014C2  FA0000     LNK #0x0
232:                   if(IFS4bits.PWM3IF)
0014C4  804041     MOV IFS4, W1
0014C6  200200     MOV #0x20, W0
0014C8  608000     AND W1, W0, W0
0014CA  E00000     CP0 W0
0014CC  320002     BRA Z, .L6
233:                   {
234:                       // PWM Generator3 callback function 
235:                       PWM_Generator3_CallBack();
0014CE  07FFF6     RCALL PWM_Generator3_CallBack
236:               
237:                       // clear the PWM Generator3 interrupt flag
238:                       IFS4bits.PWM3IF = 0;
0014D0  A9A808     BCLR IFS4, #5
239:                   }
240:               }
0014D2  FA8000     ULNK
0014D4  060000     RETURN
241:               
242:               
243:               void __attribute__ ((weak)) PWM_EventA_CallBack(void)
244:               {
0014D6  FA0000     LNK #0x0
245:                   // Add Application code here
246:               }
0014D8  FA8000     ULNK
0014DA  060000     RETURN
247:               
248:               void PWM_EventA_Tasks(void)
249:               {
0014DC  FA0000     LNK #0x0
250:                   if(IFS10bits.PEVTAIF)
0014DE  8040A1     MOV IFS10, W1
0014E0  202000     MOV #0x200, W0
0014E2  608000     AND W1, W0, W0
0014E4  E00000     CP0 W0
0014E6  320002     BRA Z, .L9
251:                   {
252:                    
253:                       // PWM EventA callback function 
254:                       PWM_EventA_CallBack();
0014E8  07FFF6     RCALL PWM_EventA_CallBack
255:               	
256:                       // clear the PWM EventA interrupt flag
257:                       IFS10bits.PEVTAIF = 0;
0014EA  A92815     BCLR 0x815, #1
258:                   }
259:               }
0014EC  FA8000     ULNK
0014EE  060000     RETURN
260:               void __attribute__ ((weak)) PWM_EventB_CallBack(void)
261:               {
0014F0  FA0000     LNK #0x0
262:                   // Add Application code here
263:               }
0014F2  FA8000     ULNK
0014F4  060000     RETURN
264:               
265:               void PWM_EventB_Tasks(void)
266:               {
0014F6  FA0000     LNK #0x0
267:                   if(IFS10bits.PEVTBIF)
0014F8  8040A1     MOV IFS10, W1
0014FA  204000     MOV #0x400, W0
0014FC  608000     AND W1, W0, W0
0014FE  E00000     CP0 W0
001500  320002     BRA Z, .L12
268:                   {
269:                    
270:                       // PWM EventB callback function 
271:                       PWM_EventB_CallBack();
001502  07FFF6     RCALL PWM_EventB_CallBack
272:               	
273:                       // clear the PWM EventB interrupt flag
274:                       IFS10bits.PEVTBIF = 0;
001504  A94815     BCLR 0x815, #2
275:                   }
276:               }
001506  FA8000     ULNK
001508  060000     RETURN
277:               void __attribute__ ((weak)) PWM_EventC_CallBack(void)
278:               {
00150A  FA0000     LNK #0x0
279:                   // Add Application code here
280:               }
00150C  FA8000     ULNK
00150E  060000     RETURN
281:               
282:               void PWM_EventC_Tasks(void)
283:               {
001510  FA0000     LNK #0x0
284:                   if(IFS10bits.PEVTCIF)
001512  8040A1     MOV IFS10, W1
001514  208000     MOV #0x800, W0
001516  608000     AND W1, W0, W0
001518  E00000     CP0 W0
00151A  320002     BRA Z, .L15
285:                   {
286:                    
287:                       // PWM EventC callback function 
288:                       PWM_EventC_CallBack();
00151C  07FFF6     RCALL PWM_EventC_CallBack
289:               	
290:                       // clear the PWM EventC interrupt flag
291:                       IFS10bits.PEVTCIF = 0;
00151E  A96815     BCLR 0x815, #3
292:                   }
293:               }
001520  FA8000     ULNK
001522  060000     RETURN
294:               void __attribute__ ((weak)) PWM_EventD_CallBack(void)
295:               {
001524  FA0000     LNK #0x0
296:                   // Add Application code here
297:               }
001526  FA8000     ULNK
001528  060000     RETURN
298:               
299:               void PWM_EventD_Tasks(void)
300:               {
00152A  FA0000     LNK #0x0
301:                   if(IFS10bits.PEVTDIF)
00152C  8040A1     MOV IFS10, W1
00152E  210000     MOV #0x1000, W0
001530  608000     AND W1, W0, W0
001532  E00000     CP0 W0
001534  320002     BRA Z, .L18
302:                   {
303:                    
304:                       // PWM EventD callback function 
305:                       PWM_EventD_CallBack();
001536  07FFF6     RCALL PWM_EventD_CallBack
306:               	
307:                       // clear the PWM EventD interrupt flag
308:                       IFS10bits.PEVTDIF = 0;
001538  A98815     BCLR 0x815, #4
309:                   }
310:               }
00153A  FA8000     ULNK
00153C  060000     RETURN
311:               void __attribute__ ((weak)) PWM_EventE_CallBack(void)
312:               {
00153E  FA0000     LNK #0x0
313:                   // Add Application code here
314:               }
001540  FA8000     ULNK
001542  060000     RETURN
315:               
316:               void PWM_EventE_Tasks(void)
317:               {
001544  FA0000     LNK #0x0
318:                   if(IFS10bits.PEVTEIF)
001546  8040A1     MOV IFS10, W1
001548  220000     MOV #0x2000, W0
00154A  608000     AND W1, W0, W0
00154C  E00000     CP0 W0
00154E  320002     BRA Z, .L21
319:                   {
320:                    
321:                       // PWM EventE callback function 
322:                       PWM_EventE_CallBack();
001550  07FFF6     RCALL PWM_EventE_CallBack
323:               	
324:                       // clear the PWM EventE interrupt flag
325:                       IFS10bits.PEVTEIF = 0;
001552  A9A815     BCLR 0x815, #5
326:                   }
327:               }
001554  FA8000     ULNK
001556  060000     RETURN
328:               void __attribute__ ((weak)) PWM_EventF_CallBack(void)
329:               {
001558  FA0000     LNK #0x0
330:                   // Add Application code here
331:               }
00155A  FA8000     ULNK
00155C  060000     RETURN
332:               
333:               void PWM_EventF_Tasks(void)
334:               {
00155E  FA0000     LNK #0x0
335:                   if(IFS10bits.PEVTFIF)
001560  8040A1     MOV IFS10, W1
001562  240000     MOV #0x4000, W0
001564  608000     AND W1, W0, W0
001566  E00000     CP0 W0
001568  320002     BRA Z, .L24
336:                   {
337:                    
338:                       // PWM EventF callback function 
339:                       PWM_EventF_CallBack();
00156A  07FFF6     RCALL PWM_EventF_CallBack
340:               	
341:                       // clear the PWM EventF interrupt flag
342:                       IFS10bits.PEVTFIF = 0;
00156C  A9C815     BCLR 0x815, #6
343:                   }
344:               }
00156E  FA8000     ULNK
001570  060000     RETURN
---  C:/Users/NapAp/Documents/Ecole/M2/Q1/Projet/Software/E_Comet_All_ADC_PWM_OPAMP/mcc_generated_files/pin_manager.c
1:                 /**
2:                   PIN MANAGER Generated Driver File
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     pin_manager.c
9:                 
10:                  @Summary:
11:                    This is the generated manager file for the PIC24 / dsPIC33 / PIC32MM MCUs device.  This manager
12:                    configures the pins direction, initial state, analog setting.
13:                    The peripheral pin select, PPS, configuration is also handled by this manager.
14:                
15:                  @Description:
16:                    This source file provides implementations for PIN MANAGER.
17:                    Generation Information :
18:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.171.4
19:                        Device            :  dsPIC33CK32MP105
20:                    The generated drivers are tested against the following:
21:                        Compiler          :  XC16 v2.10
22:                        MPLAB 	          :  MPLAB X v6.05
23:                */
24:                
25:                /*
26:                    (c) 2020 Microchip Technology Inc. and its subsidiaries. You may use this
27:                    software and any derivatives exclusively with Microchip products.
28:                
29:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
30:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
31:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
32:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
33:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
34:                
35:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
36:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
37:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
38:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
39:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
40:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
41:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
42:                
43:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
44:                    TERMS.
45:                */
46:                
47:                
48:                /**
49:                    Section: Includes
50:                */
51:                
52:                #include <xc.h>
53:                #include <stdio.h>
54:                #include "pin_manager.h"
55:                
56:                /**
57:                 Section: Driver Interface Function Definitions
58:                */
59:                void PIN_MANAGER_Initialize (void)
60:                {
00179A  FA0000     LNK #0x0
61:                    /****************************************************************************
62:                     * Setting the Output Latch SFR(s)
63:                     ***************************************************************************/
64:                    LATA = 0x0000;
00179C  EF2E06     CLR LATA
65:                    LATB = 0x0000;
00179E  EF2E22     CLR LATB
66:                    LATC = 0x0000;
0017A0  EF2E3E     CLR LATC
67:                    LATD = 0x0000;
0017A2  EF2E5A     CLR LATD
68:                
69:                    /****************************************************************************
70:                     * Setting the GPIO Direction SFR(s)
71:                     ***************************************************************************/
72:                    TRISA = 0x001E;
0017A4  2001E0     MOV #0x1E, W0
0017A6  887010     MOV W0, TRISA
73:                    TRISB = 0x33FD;
0017A8  233FD0     MOV #0x33FD, W0
0017AA  8870F0     MOV W0, TRISB
74:                    TRISC = 0x3FFF;
0017AC  23FFF0     MOV #0x3FFF, W0
0017AE  8871D0     MOV W0, TRISC
75:                    TRISD = 0x2502;
0017B0  225020     MOV #0x2502, W0
0017B2  8872B0     MOV W0, TRISD
76:                
77:                    /****************************************************************************
78:                     * Setting the Weak Pull Up and Weak Pull Down SFR(s)
79:                     ***************************************************************************/
80:                    CNPDA = 0x0000;
0017B4  EF2E0C     CLR CNPDA
81:                    CNPDB = 0x0000;
0017B6  EF2E28     CLR CNPDB
82:                    CNPDC = 0x0000;
0017B8  EF2E44     CLR CNPDC
83:                    CNPDD = 0x0000;
0017BA  EF2E60     CLR CNPDD
84:                    CNPUA = 0x0000;
0017BC  EF2E0A     CLR CNPUA
85:                    CNPUB = 0x0000;
0017BE  EF2E26     CLR CNPUB
86:                    CNPUC = 0x0000;
0017C0  EF2E42     CLR CNPUC
87:                    CNPUD = 0x0000;
0017C2  EF2E5E     CLR CNPUD
88:                
89:                    /****************************************************************************
90:                     * Setting the Open Drain SFR(s)
91:                     ***************************************************************************/
92:                    ODCA = 0x0000;
0017C4  EF2E08     CLR ODCA
93:                    ODCB = 0x0000;
0017C6  EF2E24     CLR ODCB
94:                    ODCC = 0x0000;
0017C8  EF2E40     CLR ODCC
95:                    ODCD = 0x0000;
0017CA  EF2E5C     CLR ODCD
96:                
97:                    /****************************************************************************
98:                     * Setting the Analog/Digital Configuration SFR(s)
99:                     ***************************************************************************/
100:                   ANSELA = 0x001E;
0017CC  2001E0     MOV #0x1E, W0
0017CE  887000     MOV W0, ANSELA
101:                   ANSELB = 0x009C;
0017D0  2009C0     MOV #0x9C, W0
0017D2  8870E0     MOV W0, ANSELB
102:                   ANSELC = 0x00CF;
0017D4  200CF0     MOV #0xCF, W0
0017D6  8871C0     MOV W0, ANSELC
103:                   ANSELD = 0x2400;
0017D8  224000     MOV #0x2400, W0
0017DA  8872A0     MOV W0, ANSELD
104:                   
105:                   /****************************************************************************
106:                    * Set the PPS
107:                    ***************************************************************************/
108:                   __builtin_write_RPCON(0x0000); // unlock PPS
0017DC  EB0000     CLR W0
0017DE  200551     MOV #0x55, W1
0017E0  8846B1     MOV W1, NVMKEY
0017E2  200AA1     MOV #0xAA, W1
0017E4  8846B1     MOV W1, NVMKEY
0017E6  886800     MOV W0, RPCON
109:               
110:                   RPINR7bits.ICM5R = 0x0020;    //RB0->MCCP5:ICM5
0017E8  B3C200     MOV.B #0x20, W0
0017EA  B7ED13     MOV.B WREG, 0xD13
111:               
112:                   __builtin_write_RPCON(0x0800); // lock PPS
0017EC  208000     MOV #0x800, W0
0017EE  200551     MOV #0x55, W1
0017F0  8846B1     MOV W1, NVMKEY
0017F2  200AA1     MOV #0xAA, W1
0017F4  8846B1     MOV W1, NVMKEY
0017F6  886800     MOV W0, RPCON
113:               }
0017F8  FA8000     ULNK
0017FA  060000     RETURN
114:               
---  C:/Users/NapAp/Documents/Ecole/M2/Q1/Projet/Software/E_Comet_All_ADC_PWM_OPAMP/mcc_generated_files/opa.c
1:                 
2:                 /**
3:                   OPA Generated Driver API Source File
4:                 
5:                   @Company
6:                     Microchip Technology Inc.
7:                 
8:                   @File Name
9:                     opa.c
10:                
11:                  @Summary
12:                    This is the generated driver implementation file for the OPA driver using PIC24 / dsPIC33 / PIC32MM MCUs
13:                
14:                  @Description
15:                    This source file provides APIs for driver for OPA.
16:                    Generation Information :
17:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.171.4
18:                        Device            :  dsPIC33CK32MP105
19:                    The generated drivers are tested against the following:
20:                        Compiler          :  XC16 v2.10
21:                        MPLAB 	          :  MPLAB X v6.05
22:                */
23:                
24:                /*
25:                    (c) 2020 Microchip Technology Inc. and its subsidiaries. You may use this
26:                    software and any derivatives exclusively with Microchip products.
27:                
28:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
32:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
33:                
34:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:                
42:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
43:                    TERMS.
44:                */
45:                
46:                /**
47:                  Section: Included Files
48:                */
49:                
50:                #include "opa.h"
51:                
52:                /**
53:                  Section: OPA APIs
54:                */
55:                
56:                
57:                void OPA_Initialize (void)
58:                {
0018FE  FA0000     LNK #0x0
59:                    // Set the OPA to the options selected in the User Interface
60:                
61:                    // AMPEN2 disabled; AMPEN1 enabled; AMPEN3 disabled; AMPON enabled; 
62:                    AMPCON1L = 0x8001; //Disabling AMPPON bit initially
001900  280010     MOV #0x8001, W0
001902  8846E0     MOV W0, AMPCON1L
63:                    // NCHDIS2 Wide input voltage range; NCHDIS1 Wide input voltage range; NCHDIS3 Wide input voltage range; 
64:                    AMPCON1H = 0x00;
001904  EF28DE     CLR AMPCON1H
65:                    
66:                    OPA_Enable();
001906  07FFF7     RCALL _OPA_Enable, .Ltext0, .LFB0, .Letext0, .LFE1
67:                    
68:                }
001908  FA8000     ULNK
00190A  060000     RETURN
69:                
70:                
71:                /**
72:                 End of File
73:                */
---  C:/Users/NapAp/Documents/Ecole/M2/Q1/Projet/Software/E_Comet_All_ADC_PWM_OPAMP/mcc_generated_files/mccp5_capture.c
1:                 /**
2:                   MCCP5 Generated Driver File 
3:                 
4:                   @Company
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name
8:                     mccp5.c
9:                 
10:                  @Summary
11:                    This is the generated driver implementation file for the MCCP5 driver using PIC24 / dsPIC33 / PIC32MM MCUs
12:                
13:                  @Description
14:                    This header file provides implementations for driver APIs for MCCP5. 
15:                    Generation Information : 
16:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.171.4
17:                        Device            :  dsPIC33CK32MP105
18:                    The generated drivers are tested against the following:
19:                        Compiler          :  XC16 v2.10
20:                        MPLAB             :  MPLAB X v6.05
21:                */
22:                
23:                /*
24:                    (c) 2020 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                /**
46:                  Section: Included Files
47:                */
48:                
49:                #include "mccp5_capture.h"
50:                
51:                
52:                void MCCP5_CAPTURE_Initialize(void)
53:                {
001686  FA0000     LNK #0x0
54:                    // CCPON enabled; MOD Edge Detect; CCSEL enabled; CCPSIDL disabled; T32 16 Bit; CCPSLP disabled; TMRPS 1:1; CLKSEL FOSC/2; TMRSYNC disabled; 
55:                    CCP5CON1L = (0x8010 & 0x7FFF); //Disabling CCPON bit
001688  200100     MOV #0x10, W0
00168A  884F00     MOV W0, CCP5CON1L
56:                    //RTRGEN disabled; ALTSYNC disabled; ONESHOT disabled; TRIGEN disabled; OPS Each IC Event; SYNC None; OPSSRC Timer Interrupt Event; 
57:                    CCP5CON1H = 0x00;
00168C  EF29E2     CLR CCP5CON1H
58:                    //ASDGM disabled; SSDG disabled; ASDG 0; PWMRSEN disabled; 
59:                    CCP5CON2L = 0x00;
00168E  EF29E4     CLR CCP5CON2L
60:                    //OCCEN disabled; OCDEN disabled; OCEEN disabled; ICGSM Level-Sensitive mode; OCFEN disabled; ICSEL IC5; AUXOUT Disabled; OCAEN disabled; OCBEN disabled; OENSYNC disabled; 
61:                    CCP5CON2H = 0x00;
001690  EF29E6     CLR CCP5CON2H
62:                    //DT 0; 
63:                    CCP5CON3L = 0x00;
001692  EF29E8     CLR CCP5CON3L
64:                    //OETRIG disabled; OSCNT None; POLACE disabled; POLBDF disabled; PSSBDF Tri-state; OUTM Steerable single output; PSSACE Tri-state; 
65:                    CCP5CON3H = 0x00;
001694  EF29EA     CLR CCP5CON3H
66:                    //ICDIS disabled; SCEVT disabled; TRSET disabled; ICOV disabled; ASEVT disabled; ICGARM disabled; TRCLR disabled; 
67:                    CCP5STATL = 0x00;
001696  EF29EC     CLR CCP5STATL
68:                    //TMR 0; 
69:                    CCP5TMRL = 0x00;
001698  EF29F0     CLR CCP5TMRL
70:                    //TMR 0; 
71:                    CCP5TMRH = 0x00;
00169A  EF29F2     CLR CCP5TMRH
72:                    //PR 0; 
73:                    CCP5PRL = 0x00;
00169C  EF29F4     CLR CCP5PRL
74:                    //PR 0; 
75:                    CCP5PRH = 0x00;
00169E  EF29F6     CLR CCP5PRH
76:                    //CMP 0; 
77:                    CCP5RA = 0x00;
0016A0  EF29F8     CLR CCP5RAL
78:                    //CMP 0; 
79:                    CCP5RB = 0x00;
0016A2  EF29FC     CLR CCP5RBL
80:                    //BUF 0; 
81:                    CCP5BUFL = 0x00;
0016A4  EF2A00     CLR CCP5BUFL
82:                    //BUF 0; 
83:                    CCP5BUFH = 0x00;
0016A6  EF2A02     CLR CCP5BUFH
84:                
85:                    CCP5CON1Lbits.CCPON = 0x1; //Enabling CCP
0016A8  A8E9E1     BSET 0x9E1, #7
86:                
87:                
88:                }
0016AA  FA8000     ULNK
0016AC  060000     RETURN
89:                
90:                void MCCP5_CAPTURE_Start( void )
91:                {
0016AE  FA0000     LNK #0x0
92:                    /* Start the Timer */
93:                    CCP5CON1Lbits.CCPON = true;
0016B0  A8E9E1     BSET 0x9E1, #7
94:                }
0016B2  FA8000     ULNK
0016B4  060000     RETURN
95:                
96:                void MCCP5_CAPTURE_Stop( void )
97:                {
0016B6  FA0000     LNK #0x0
98:                    /* Stop the Timer */
99:                    CCP5CON1Lbits.CCPON = false;
0016B8  A9E9E1     BCLR 0x9E1, #7
100:               }
0016BA  FA8000     ULNK
0016BC  060000     RETURN
101:               
102:               void __attribute__ ((weak)) MCCP5_CAPTURE_CallBack(void)
103:               {
0016BE  FA0000     LNK #0x0
104:                   // Add your custom callback code here
105:               }
0016C0  FA8000     ULNK
0016C2  060000     RETURN
106:               
107:               
108:               void MCCP5_CAPTURE_Tasks( void )
109:               {
0016C4  FA0000     LNK #0x0
110:                   /* Check if the Timer Interrupt/Status is set */
111:                   if(IFS2bits.CCP5IF)
0016C6  804021     MOV IFS2, W1
0016C8  208000     MOV #0x800, W0
0016CA  608000     AND W1, W0, W0
0016CC  E00000     CP0 W0
0016CE  320002     BRA Z, .L5
112:                   {
113:               		// MCCP5 CAPTURE callback function 
114:               		MCCP5_CAPTURE_CallBack();
0016D0  07FFF6     RCALL MCCP5_CAPTURE_CallBack
115:                       
116:                       IFS2bits.CCP5IF = 0;
0016D2  A96805     BCLR 0x805, #3
117:                   }
118:               }
0016D4  FA8000     ULNK
0016D6  060000     RETURN
119:               
120:               void __attribute__ ((weak)) MCCP5_CAPTURE_TimerCallBack(void)
121:               {
0016D8  FA0000     LNK #0x0
122:                   // Add your custom callback code here
123:               }
0016DA  FA8000     ULNK
0016DC  060000     RETURN
124:               
125:               
126:               void MCCP5_CAPTURE_TimerTasks( void )
127:               {
0016DE  FA0000     LNK #0x0
128:                   if(IFS2bits.CCT5IF)
0016E0  804021     MOV IFS2, W1
0016E2  210000     MOV #0x1000, W0
0016E4  608000     AND W1, W0, W0
0016E6  E00000     CP0 W0
0016E8  320002     BRA Z, .L8
129:                   {
130:               		// MCCP5 CAPTURE Timer callback function 
131:               		MCCP5_CAPTURE_TimerCallBack();
0016EA  07FFF6     RCALL MCCP5_CAPTURE_TimerCallBack
132:               
133:                       IFS2bits.CCT5IF = 0;
0016EC  A98805     BCLR 0x805, #4
134:                   }
135:               }
0016EE  FA8000     ULNK
0016F0  060000     RETURN
136:               
137:               uint16_t MCCP5_CAPTURE_Data16Read( void )
138:               {
0016F2  FA0000     LNK #0x0
139:                   /* Return the captured timer data */
140:                   return(CCP5BUFL);
0016F4  805000     MOV CCP5BUFL, W0
141:               
142:               }
0016F6  FA8000     ULNK
0016F8  060000     RETURN
143:               
144:               
145:               bool MCCP5_CAPTURE_HasBufferOverflowed( void )
146:               {
0016FA  FA0000     LNK #0x0
147:                   return( CCP5STATLbits.ICOV );
0016FC  804F60     MOV CCP5STATL, W0
0016FE  0A8011     BFEXT #0x1, #0x1, W0, W0
001700  000000     NOP
001702  FB8000     ZE W0, W0
001704  A7F000     BTSC W0, #15
001706  EA0000     NEG W0, W0
001708  EA0000     NEG W0, W0
00170A  DE004F     LSR W0, #15, W0
00170C  784000     MOV.B W0, W0
148:               }
00170E  FA8000     ULNK
001710  060000     RETURN
149:               
150:               bool MCCP5_CAPTURE_IsBufferEmpty( void )
151:               {
001712  FA0000     LNK #0x0
152:                   return( ! CCP5STATLbits.ICBNE );
001714  804F60     MOV CCP5STATL, W0
001716  600061     AND W0, #0x1, W0
001718  A7F000     BTSC W0, #15
00171A  EA0000     NEG W0, W0
00171C  E90000     DEC W0, W0
00171E  DE004F     LSR W0, #15, W0
001720  784000     MOV.B W0, W0
153:               }
001722  FA8000     ULNK
001724  060000     RETURN
154:               
155:               void MCCP5_CAPTURE_OverflowFlagReset( void )
156:               {
001726  FA0000     LNK #0x0
157:                   CCP5STATLbits.ICOV = 0;
001728  A929EC     BCLR CCP5STATL, #1
158:               }
00172A  FA8000     ULNK
00172C  060000     RETURN
159:               /**
160:                End of File
161:               */
---  C:/Users/NapAp/Documents/Ecole/M2/Q1/Projet/Software/E_Comet_All_ADC_PWM_OPAMP/mcc_generated_files/interrupt_manager.c
1:                 /**
2:                   System Interrupts Generated Driver File 
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     interrupt_manager.h
9:                 
10:                  @Summary:
11:                    This is the generated driver implementation file for setting up the
12:                    interrupts using PIC24 / dsPIC33 / PIC32MM MCUs
13:                
14:                  @Description:
15:                    This source file provides implementations for PIC24 / dsPIC33 / PIC32MM MCUs interrupts.
16:                    Generation Information : 
17:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.171.4
18:                        Device            :  dsPIC33CK32MP105
19:                    The generated drivers are tested against the following:
20:                        Compiler          :  XC16 v2.10
21:                        MPLAB             :  MPLAB X v6.05
22:                */
23:                /*
24:                    (c) 2020 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                /**
46:                    Section: Includes
47:                */
48:                #include <xc.h>
49:                
50:                /**
51:                    void INTERRUPT_Initialize (void)
52:                */
53:                void INTERRUPT_Initialize (void)
54:                {
00189C  FA0000     LNK #0x0
55:                    //    ADCAN19: ADC AN19 Convert Done
56:                    //    Priority: 1
57:                        IPC27bits.ADCAN19IP = 1;
00189E  8043B1     MOV IPC27, W1
0018A0  2F8FF0     MOV #0xF8FF, W0
0018A2  608000     AND W1, W0, W0
0018A4  A08000     BSET W0, #8
0018A6  8843B0     MOV W0, IPC27
58:                    //    ADCAN17: ADC AN17 Convert Done
59:                    //    Priority: 1
60:                        IPC27bits.ADCAN17IP = 1;
0018A8  8043B1     MOV IPC27, W1
0018AA  2FFF80     MOV #0xFFF8, W0
0018AC  608000     AND W1, W0, W0
0018AE  A00000     BSET W0, #0
0018B0  8843B0     MOV W0, IPC27
61:                    //    ADCAN20: ADC AN20 Convert Done
62:                    //    Priority: 1
63:                        IPC27bits.ADCAN20IP = 1;
0018B2  8043B1     MOV IPC27, W1
0018B4  28FFF0     MOV #0x8FFF, W0
0018B6  608000     AND W1, W0, W0
0018B8  A0C000     BSET W0, #12
0018BA  8843B0     MOV W0, IPC27
64:                }
0018BC  FA8000     ULNK
0018BE  060000     RETURN
---  C:/Users/NapAp/Documents/Ecole/M2/Q1/Projet/Software/E_Comet_All_ADC_PWM_OPAMP/mcc_generated_files/clock.c
1:                 /**
2:                   @Generated PIC24 / dsPIC33 / PIC32MM MCUs Source File
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     clock.c
9:                 
10:                  @Summary:
11:                    This is the clock.c file generated using PIC24 / dsPIC33 / PIC32MM MCUs
12:                
13:                  @Description:
14:                    This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                    Generation Information :
16:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.171.4
17:                        Device            :  dsPIC33CK32MP105
18:                    The generated drivers are tested against the following:
19:                        Compiler          :  XC16 v2.10
20:                        MPLAB             :  MPLAB X v6.05
21:                */
22:                
23:                /*
24:                    (c) 2020 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                #include <stdint.h>
46:                #include "xc.h"
47:                #include "clock.h"
48:                
49:                void CLOCK_Initialize(void)
50:                {
00172E  FA0000     LNK #0x0
51:                    // FRCDIV FRC/1; PLLPRE 1; DOZE 1:8; DOZEN disabled; ROI disabled; 
52:                    CLKDIV = 0x3001;
001730  230010     MOV #0x3001, W0
001732  887C30     MOV W0, CLKDIV
53:                    // PLLFBDIV 150; 
54:                    PLLFBD = 0x96;
001734  200960     MOV #0x96, W0
001736  887C40     MOV W0, PLLFBD
55:                    // TUN Center frequency; 
56:                    OSCTUN = 0x00;
001738  EF2F8C     CLR OSCTUN
57:                    // POST1DIV 1:4; VCODIV FVCO/4; POST2DIV 1:1; 
58:                    PLLDIV = 0x41;
00173A  200410     MOV #0x41, W0
00173C  887C50     MOV W0, PLLDIV
59:                    // APLLEN disabled; FRCSEL FRC; APLLPRE 1:1; 
60:                    ACLKCON1 = 0x101;
00173E  201010     MOV #0x101, W0
001740  887C70     MOV W0, ACLKCON1
61:                    // APLLFBDIV 150; 
62:                    APLLFBD1 = 0x96;
001742  200960     MOV #0x96, W0
001744  887C80     MOV W0, APLLFBD1
63:                    // APOST1DIV 1:4; APOST2DIV 1:1; AVCODIV FVCO/4; 
64:                    APLLDIV1 = 0x41;
001746  200410     MOV #0x41, W0
001748  887C90     MOV W0, APLLDIV1
65:                    // ROEN disabled; ROSWEN disabled; ROSLP disabled; ROSEL FOSC; ROOUT disabled; ROSIDL disabled; 
66:                    REFOCONL = 0x00;
00174A  EF2FB8     CLR REFOCONL
67:                    // RODIV 0; 
68:                    REFOCONH = 0x00;
00174C  EF2FBA     CLR REFOCONH
69:                    // ROTRIM 0; 
70:                    REFOTRIMH = 0x00;
00174E  EF2FBE     CLR 0xFBE
71:                    // IOLOCK disabled; 
72:                    RPCON = 0x00;
001750  EF2D00     CLR RPCON
73:                    // PMDLOCK disabled; 
74:                    PMDCON = 0x00;
001752  EF2FA0     CLR PMDCON
75:                    // ADC1MD enabled; T1MD enabled; U2MD enabled; U1MD enabled; SPI2MD enabled; SPI1MD enabled; QEIMD enabled; PWMMD enabled; I2C1MD enabled; 
76:                    PMD1 = 0x00;
001754  EF2FA4     CLR PMD1
77:                    // CCP2MD enabled; CCP1MD enabled; CCP4MD enabled; CCP3MD enabled; CCP5MD enabled; 
78:                    PMD2 = 0x00;
001756  EF2FA6     CLR PMD2
79:                    // PMPMD enabled; U3MD enabled; QEI2MD enabled; CRCMD enabled; I2C2MD enabled; 
80:                    PMD3 = 0x00;
001758  EF2FA8     CLR PMD3
81:                    // REFOMD enabled; 
82:                    PMD4 = 0x00;
00175A  EF2FAA     CLR PMD4
83:                    // DMA1MD enabled; SPI3MD enabled; DMA2MD enabled; DMA3MD enabled; DMA0MD enabled; 
84:                    PMD6 = 0x00;
00175C  EF2FAE     CLR PMD6
85:                    // CMP3MD enabled; PTGMD enabled; CMP1MD enabled; CMP2MD enabled; 
86:                    PMD7 = 0x00;
00175E  EF2FB0     CLR PMD7
87:                    // DMTMD enabled; CLC3MD enabled; OPAMPMD enabled; BIASMD enabled; CLC4MD enabled; SENT2MD enabled; SENT1MD enabled; CLC1MD enabled; CLC2MD enabled; 
88:                    PMD8 = 0x00;
001760  EF2FB2     CLR PMD8
89:                    // CF no clock failure; NOSC FRCDIV; CLKLOCK unlocked; OSWEN Switch is Complete; 
90:                    __builtin_write_OSCCONH((uint8_t) (0x07));
001762  200072     MOV #0x7, W2
001764  200780     MOV #0x78, W0
001766  2009A1     MOV #0x9A, W1
001768  20F853     MOV #0xF85, W3
00176A  784980     MOV.B W0, [W3]
00176C  784981     MOV.B W1, [W3]
00176E  784982     MOV.B W2, [W3]
91:                    __builtin_write_OSCCONL((uint8_t) (0x00));
001770  EB0100     CLR W2
001772  200460     MOV #0x46, W0
001774  200571     MOV #0x57, W1
001776  20F843     MOV #0xF84, W3
001778  784980     MOV.B W0, [W3]
00177A  784981     MOV.B W1, [W3]
00177C  784982     MOV.B W2, [W3]
92:                }
00177E  FA8000     ULNK
001780  060000     RETURN
93:                
94:                bool CLOCK_AuxPllLockStatusGet()
95:                {
001782  FA0000     LNK #0x0
96:                    return ACLKCON1bits.APLLCK;
001784  807C70     MOV ACLKCON1, W0
001786  0A80EE     BFEXT #0xe, #0x1, W0, W0
001788  000000     NOP
00178A  FB8000     ZE W0, W0
00178C  A7F000     BTSC W0, #15
00178E  EA0000     NEG W0, W0
001790  EA0000     NEG W0, W0
001792  DE004F     LSR W0, #15, W0
001794  784000     MOV.B W0, W0
97:                }
001796  FA8000     ULNK
001798  060000     RETURN
---  C:/Users/NapAp/Documents/Ecole/M2/Q1/Projet/Software/E_Comet_All_ADC_PWM_OPAMP/mcc_generated_files/adc1.c
1:                 /**
2:                   ADC1 Generated Driver File
3:                 
4:                   @Company
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name
8:                     adc1.c
9:                 
10:                  @Summary
11:                    This is the generated driver implementation file for the ADC1 driver using PIC24 / dsPIC33 / PIC32MM MCUs
12:                
13:                  @Description
14:                    This source file provides APIs for ADC1.
15:                    Generation Information :
16:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.171.4
17:                        Device            :  dsPIC33CK32MP105      
18:                    The generated drivers are tested against the following:
19:                        Compiler          :  XC16 v2.10
20:                        MPLAB 	          :  MPLAB X v6.05
21:                */
22:                
23:                /*
24:                    (c) 2020 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                /**
46:                  Section: Included Files
47:                */
48:                
49:                #include "adc1.h"
50:                
51:                /**
52:                 Section: File specific functions
53:                */
54:                
55:                static void (*ADC1_CommonDefaultInterruptHandler)(void);
56:                static void (*ADC1_channel_AN7DefaultInterruptHandler)(uint16_t adcVal);
57:                static void (*ADC1_channel_AN12DefaultInterruptHandler)(uint16_t adcVal);
58:                static void (*ADC1_channel_AN15DefaultInterruptHandler)(uint16_t adcVal);
59:                static void (*ADC1_channel_AN17DefaultInterruptHandler)(uint16_t adcVal);
60:                static void (*ADC1_channel_AN19DefaultInterruptHandler)(uint16_t adcVal);
61:                static void (*ADC1_channel_AN20DefaultInterruptHandler)(uint16_t adcVal);
62:                
63:                /**
64:                  Section: Driver Interface
65:                */
66:                
67:                void ADC1_Initialize (void)
68:                {
0011E6  FA0000     LNK #0x0
69:                    // ADSIDL disabled; CVDEN disabled; ADON enabled; 
70:                    ADCON1L = (0x8000 & 0x7FFF); //Disabling ADON bit
0011E8  EF2B00     CLR ADCON1L
71:                    // FORM Integer; SHRRES 12-bit resolution; 
72:                    ADCON1H = 0x60;
0011EA  200600     MOV #0x60, W0
0011EC  885810     MOV W0, ADCON1H
73:                    // PTGEN disabled; SHRADCS 2; REFCIE disabled; SHREISEL Early interrupt is generated 1 TADCORE clock prior to data being ready; REFERCIE disabled; EIEN disabled; 
74:                    ADCON2L = 0x00;
0011EE  EF2B04     CLR ADCON2L
75:                    // CVDCAP disabled; SHRSAMC 0; 
76:                    ADCON2H = 0x00;
0011F0  EF2B06     CLR ADCON2H
77:                    // SWCTRG disabled; SHRSAMP disabled; SUSPEND disabled; SWLCTRG disabled; SUSPCIE disabled; CNVCHSEL AN0; REFSEL disabled; 
78:                    ADCON3L = 0x00;
0011F2  EF2B08     CLR ADCON3L
79:                    // SHREN enabled; C1EN disabled; C0EN disabled; CLKDIV 1; CLKSEL FOSC/2; 
80:                    ADCON3H = (0x80 & 0xFF00); //Disabling C0EN, C1EN, C2EN, C3EN and SHREN bits
0011F4  EF2B0A     CLR ADCON3H
81:                    // SAMC0EN disabled; SAMC1EN disabled; 
82:                    ADCON4L = 0x00;
0011F6  EF2B0C     CLR ADCON4L
83:                    // C0CHS AN0; C1CHS ANA1; 
84:                    ADCON4H = 0x04;
0011F8  200040     MOV #0x4, W0
0011FA  885870     MOV W0, ADCON4H
85:                    // SIGN0 disabled; SIGN4 disabled; SIGN3 disabled; SIGN2 disabled; SIGN1 disabled; SIGN7 disabled; SIGN6 disabled; DIFF0 disabled; SIGN5 disabled; DIFF1 disabled; DIFF2 disabled; DIFF3 disabled; DIFF4 disabled; DIFF5 disabled; DIFF6 disabled; DIFF7 disabled; 
86:                    ADMOD0L = 0x00;
0011FC  EF2B10     CLR ADMOD0L
87:                    // DIFF15 disabled; DIFF14 disabled; SIGN8 disabled; DIFF13 disabled; SIGN14 disabled; DIFF12 disabled; SIGN15 disabled; DIFF11 disabled; DIFF10 disabled; SIGN9 disabled; DIFF8 disabled; DIFF9 disabled; SIGN10 disabled; SIGN11 disabled; SIGN12 disabled; SIGN13 disabled; 
88:                    ADMOD0H = 0x00;
0011FE  EF2B12     CLR ADMOD0H
89:                    // DIFF19 disabled; DIFF18 disabled; SIGN20 disabled; DIFF17 disabled; DIFF16 disabled; SIGN16 disabled; SIGN17 disabled; SIGN18 disabled; DIFF20 disabled; SIGN19 disabled; 
90:                    ADMOD1L = 0x00;
001200  EF2B14     CLR ADMOD1L
91:                    // IE15 disabled; IE1 disabled; IE0 disabled; IE3 disabled; IE2 disabled; IE5 disabled; IE4 disabled; IE10 disabled; IE7 disabled; IE6 disabled; IE9 disabled; IE13 disabled; IE8 disabled; IE14 disabled; IE11 disabled; IE12 disabled; 
92:                    ADIEL = 0x00;
001202  EF2B20     CLR ADIEL
93:                    // IE17 enabled; IE18 disabled; IE16 disabled; IE19 enabled; IE20 enabled; 
94:                    ADIEH = 0x1A;
001204  2001A0     MOV #0x1A, W0
001206  885910     MOV W0, ADIEH
95:                    // CMPEN10 disabled; CMPEN11 disabled; CMPEN6 disabled; CMPEN5 disabled; CMPEN4 disabled; CMPEN3 disabled; CMPEN2 disabled; CMPEN1 disabled; CMPEN0 disabled; CMPEN14 disabled; CMPEN9 disabled; CMPEN15 disabled; CMPEN8 disabled; CMPEN12 disabled; CMPEN7 disabled; CMPEN13 disabled; 
96:                    ADCMP0ENL = 0x00;
001208  EF2B38     CLR ADCMP0ENL
97:                    // CMPEN10 disabled; CMPEN11 disabled; CMPEN6 disabled; CMPEN5 disabled; CMPEN4 disabled; CMPEN3 disabled; CMPEN2 disabled; CMPEN1 disabled; CMPEN0 disabled; CMPEN14 disabled; CMPEN9 disabled; CMPEN15 disabled; CMPEN8 disabled; CMPEN12 disabled; CMPEN7 disabled; CMPEN13 disabled; 
98:                    ADCMP1ENL = 0x00;
00120A  EF2B40     CLR ADCMP1ENL
99:                    // CMPEN10 disabled; CMPEN11 disabled; CMPEN6 disabled; CMPEN5 disabled; CMPEN4 disabled; CMPEN3 disabled; CMPEN2 disabled; CMPEN1 disabled; CMPEN0 disabled; CMPEN14 disabled; CMPEN9 disabled; CMPEN15 disabled; CMPEN8 disabled; CMPEN12 disabled; CMPEN7 disabled; CMPEN13 disabled; 
100:                   ADCMP2ENL = 0x00;
00120C  EF2B48     CLR ADCMP2ENL
101:                   // CMPEN10 disabled; CMPEN11 disabled; CMPEN6 disabled; CMPEN5 disabled; CMPEN4 disabled; CMPEN3 disabled; CMPEN2 disabled; CMPEN1 disabled; CMPEN0 disabled; CMPEN14 disabled; CMPEN9 disabled; CMPEN15 disabled; CMPEN8 disabled; CMPEN12 disabled; CMPEN7 disabled; CMPEN13 disabled; 
102:                   ADCMP3ENL = 0x00;
00120E  EF2B50     CLR ADCMP3ENL
103:                   // CMPEN20 disabled; CMPEN18 disabled; CMPEN19 disabled; CMPEN16 disabled; CMPEN17 disabled; 
104:                   ADCMP0ENH = 0x00;
001210  EF2B3A     CLR ADCMP0ENH
105:                   // CMPEN20 disabled; CMPEN18 disabled; CMPEN19 disabled; CMPEN16 disabled; CMPEN17 disabled; 
106:                   ADCMP1ENH = 0x00;
001212  EF2B42     CLR ADCMP1ENH
107:                   // CMPEN20 disabled; CMPEN18 disabled; CMPEN19 disabled; CMPEN16 disabled; CMPEN17 disabled; 
108:                   ADCMP2ENH = 0x00;
001214  EF2B4A     CLR ADCMP2ENH
109:                   // CMPEN20 disabled; CMPEN18 disabled; CMPEN19 disabled; CMPEN16 disabled; CMPEN17 disabled; 
110:                   ADCMP3ENH = 0x00;
001216  EF2B52     CLR ADCMP3ENH
111:                   // CMPLO 0; 
112:                   ADCMP0LO = 0x00;
001218  EF2B3C     CLR ADCMP0LO
113:                   // CMPLO 0; 
114:                   ADCMP1LO = 0x00;
00121A  EF2B44     CLR ADCMP1LO
115:                   // CMPLO 0; 
116:                   ADCMP2LO = 0x00;
00121C  EF2B4C     CLR ADCMP2LO
117:                   // CMPLO 0; 
118:                   ADCMP3LO = 0x00;
00121E  EF2B54     CLR ADCMP3LO
119:                   // CMPHI 0; 
120:                   ADCMP0HI = 0x00;
001220  EF2B3E     CLR ADCMP0HI
121:                   // CMPHI 0; 
122:                   ADCMP1HI = 0x00;
001222  EF2B46     CLR ADCMP1HI
123:                   // CMPHI 0; 
124:                   ADCMP2HI = 0x00;
001224  EF2B4E     CLR ADCMP2HI
125:                   // CMPHI 0; 
126:                   ADCMP3HI = 0x00;
001226  EF2B56     CLR ADCMP3HI
127:                   // OVRSAM 4x; MODE Oversampling Mode; FLCHSEL AN0; IE disabled; FLEN disabled; 
128:                   ADFL0CON = 0x400;
001228  204000     MOV #0x400, W0
00122A  885B50     MOV W0, ADFL0CON
129:                   // OVRSAM 4x; MODE Oversampling Mode; FLCHSEL AN0; IE disabled; FLEN disabled; 
130:                   ADFL1CON = 0x400;
00122C  204000     MOV #0x400, W0
00122E  885B70     MOV W0, ADFL1CON
131:                   // OVRSAM 4x; MODE Oversampling Mode; FLCHSEL AN0; IE disabled; FLEN disabled; 
132:                   ADFL2CON = 0x400;
001230  204000     MOV #0x400, W0
001232  885B90     MOV W0, ADFL2CON
133:                   // OVRSAM 4x; MODE Oversampling Mode; FLCHSEL AN0; IE disabled; FLEN disabled; 
134:                   ADFL3CON = 0x400;
001234  204000     MOV #0x400, W0
001236  885BB0     MOV W0, ADFL3CON
135:                   // HIHI disabled; LOLO disabled; HILO disabled; BTWN disabled; LOHI disabled; CMPEN disabled; IE disabled; 
136:                   ADCMP0CON = 0x00;
001238  EF2BA0     CLR ADCMP0CON
137:                   // HIHI disabled; LOLO disabled; HILO disabled; BTWN disabled; LOHI disabled; CMPEN disabled; IE disabled; 
138:                   ADCMP1CON = 0x00;
00123A  EF2BA4     CLR ADCMP1CON
139:                   // HIHI disabled; LOLO disabled; HILO disabled; BTWN disabled; LOHI disabled; CMPEN disabled; IE disabled; 
140:                   ADCMP2CON = 0x00;
00123C  EF2BA8     CLR ADCMP2CON
141:                   // HIHI disabled; LOLO disabled; HILO disabled; BTWN disabled; LOHI disabled; CMPEN disabled; IE disabled; 
142:                   ADCMP3CON = 0x00;
00123E  EF2BAC     CLR ADCMP3CON
143:                   // LVLEN9 disabled; LVLEN8 disabled; LVLEN11 disabled; LVLEN7 disabled; LVLEN10 disabled; LVLEN6 disabled; LVLEN13 disabled; LVLEN5 disabled; LVLEN12 disabled; LVLEN4 disabled; LVLEN15 disabled; LVLEN3 disabled; LVLEN14 disabled; LVLEN2 disabled; LVLEN1 disabled; LVLEN0 disabled; 
144:                   ADLVLTRGL = 0x00;
001240  EF2BD0     CLR ADLVLTRGL
145:                   // LVLEN20 disabled; LVLEN17 disabled; LVLEN16 disabled; LVLEN19 disabled; LVLEN18 disabled; 
146:                   ADLVLTRGH = 0x00;
001242  EF2BD2     CLR ADLVLTRGH
147:                   // SAMC 0; 
148:                   ADCORE0L = 0x00;
001244  EF2BD4     CLR ADCORE0L
149:                   // SAMC 0; 
150:                   ADCORE1L = 0x00;
001246  EF2BD8     CLR ADCORE1L
151:                   // RES 12-bit resolution; EISEL Early interrupt is generated 1 TADCORE clock prior to data being ready; ADCS 2; 
152:                   ADCORE0H = 0x300;
001248  203000     MOV #0x300, W0
00124A  885EB0     MOV W0, ADCORE0H
153:                   // RES 12-bit resolution; EISEL Early interrupt is generated 1 TADCORE clock prior to data being ready; ADCS 2; 
154:                   ADCORE1H = 0x300;
00124C  203000     MOV #0x300, W0
00124E  885ED0     MOV W0, ADCORE1H
155:                   // EIEN9 disabled; EIEN7 disabled; EIEN8 disabled; EIEN5 disabled; EIEN6 disabled; EIEN3 disabled; EIEN4 disabled; EIEN1 disabled; EIEN2 disabled; EIEN13 disabled; EIEN0 disabled; EIEN12 disabled; EIEN11 disabled; EIEN10 disabled; EIEN15 disabled; EIEN14 disabled; 
156:                   ADEIEL = 0x00;
001250  EF2BF0     CLR ADEIEL
157:                   // EIEN17 disabled; EIEN16 disabled; EIEN19 disabled; EIEN18 disabled; EIEN20 disabled; 
158:                   ADEIEH = 0x00;
001252  EF2BF2     CLR ADEIEH
159:                   // C0CIE disabled; C1CIE disabled; SHRCIE disabled; WARMTIME 32768 Source Clock Periods; 
160:                   ADCON5H = (0xF00 & 0xF0FF); //Disabling WARMTIME bit
001254  EF2C02     CLR ADCON5H
161:               	
162:                   //Assign Default Callbacks
163:                   ADC1_SetCommonInterruptHandler(&ADC1_CallBack);
001256  212F20     MOV #0x12F2, W0
001258  07004F     RCALL ADC1_SetCommonInterruptHandler
164:                   ADC1_Setchannel_AN7InterruptHandler(&ADC1_channel_AN7_CallBack);
00125A  213200     MOV #0x1320, W0
00125C  070065     RCALL ADC1_Setchannel_AN7InterruptHandler
165:                   ADC1_Setchannel_AN12InterruptHandler(&ADC1_channel_AN12_CallBack);
00125E  213540     MOV #0x1354, W0
001260  07007D     RCALL ADC1_Setchannel_AN12InterruptHandler
166:                   ADC1_Setchannel_AN15InterruptHandler(&ADC1_channel_AN15_CallBack);
001262  213880     MOV #0x1388, W0
001264  070095     RCALL ADC1_Setchannel_AN15InterruptHandler
167:                   ADC1_Setchannel_AN17InterruptHandler(&ADC1_channel_AN17_CallBack);
001266  213BC0     MOV #0x13BC, W0
001268  0700AD     RCALL ADC1_Setchannel_AN17InterruptHandler
168:                   ADC1_Setchannel_AN19InterruptHandler(&ADC1_channel_AN19_CallBack);
00126A  213D00     MOV #0x13D0, W0
00126C  0700B5     RCALL ADC1_Setchannel_AN19InterruptHandler
169:                   ADC1_Setchannel_AN20InterruptHandler(&ADC1_channel_AN20_CallBack);
00126E  213E40     MOV #0x13E4, W0
001270  0700BD     RCALL ADC1_Setchannel_AN20InterruptHandler
170:                   
171:                   // Clearing channel_AN17 interrupt flag.
172:                   IFS6bits.ADCAN17IF = 0;
001272  A9880D     BCLR 0x80D, #4
173:                   // Enabling channel_AN17 interrupt.
174:                   IEC6bits.ADCAN17IE = 1;
001274  A8882D     BSET 0x82D, #4
175:                   // Clearing channel_AN19 interrupt flag.
176:                   IFS6bits.ADCAN19IF = 0;
001276  A9C80D     BCLR 0x80D, #6
177:                   // Enabling channel_AN19 interrupt.
178:                   IEC6bits.ADCAN19IE = 1;
001278  A8C82D     BSET 0x82D, #6
179:                   // Clearing channel_AN20 interrupt flag.
180:                   IFS6bits.ADCAN20IF = 0;
00127A  A9E80D     BCLR 0x80D, #7
181:                   // Enabling channel_AN20 interrupt.
182:                   IEC6bits.ADCAN20IE = 1;
00127C  A8E82D     BSET 0x82D, #7
183:               
184:                   // Setting WARMTIME bit
185:                   ADCON5Hbits.WARMTIME = 0xF;
00127E  806011     MOV ADCON5H, W1
001280  20F000     MOV #0xF00, W0
001282  700001     IOR W0, W1, W0
001284  886010     MOV W0, ADCON5H
186:                   // Enabling ADC Module
187:                   ADCON1Lbits.ADON = 0x1;
001286  A8EB01     BSET 0xB01, #7
188:                   // Enabling Power for the Shared Core
189:                   ADC1_SharedCorePowerEnable();
001288  070029     RCALL ADC1_SharedCorePowerEnable
190:               
191:                   //TRGSRC0 None; TRGSRC1 None; 
192:                   ADTRIG0L = 0x00;
00128A  EF2B80     CLR ADTRIG0L
193:                   //TRGSRC3 None; TRGSRC2 None; 
194:                   ADTRIG0H = 0x00;
00128C  EF2B82     CLR ADTRIG0H
195:                   //TRGSRC4 None; TRGSRC5 None; 
196:                   ADTRIG1L = 0x00;
00128E  EF2B84     CLR ADTRIG1L
197:                   //TRGSRC6 None; TRGSRC7 Common Software Trigger; 
198:                   ADTRIG1H = 0x100;
001290  201000     MOV #0x100, W0
001292  885C30     MOV W0, ADTRIG1H
199:                   //TRGSRC8 None; TRGSRC9 None; 
200:                   ADTRIG2L = 0x00;
001294  EF2B88     CLR ADTRIG2L
201:                   //TRGSRC11 None; TRGSRC10 None; 
202:                   ADTRIG2H = 0x00;
001296  EF2B8A     CLR ADTRIG2H
203:                   //TRGSRC13 None; TRGSRC12 Common Software Trigger; 
204:                   ADTRIG3L = 0x01;
001298  200010     MOV #0x1, W0
00129A  885C60     MOV W0, ADTRIG3L
205:                   //TRGSRC15 Common Software Trigger; TRGSRC14 None; 
206:                   ADTRIG3H = 0x100;
00129C  201000     MOV #0x100, W0
00129E  885C70     MOV W0, ADTRIG3H
207:                   //TRGSRC17 Common Software Trigger; TRGSRC16 None; 
208:                   ADTRIG4L = 0x100;
0012A0  201000     MOV #0x100, W0
0012A2  885C80     MOV W0, ADTRIG4L
209:                   //TRGSRC19 Common Software Trigger; TRGSRC18 None; 
210:                   ADTRIG4H = 0x100;
0012A4  201000     MOV #0x100, W0
0012A6  885C90     MOV W0, ADTRIG4H
211:                   //TRGSRC20 Common Software Trigger; 
212:                   ADTRIG5L = 0x01;
0012A8  200010     MOV #0x1, W0
0012AA  885CA0     MOV W0, ADTRIG5L
213:               }
0012AC  FA8000     ULNK
0012AE  060000     RETURN
214:               
215:               void ADC1_Core0PowerEnable ( ) 
216:               {
0012B0  FA0000     LNK #0x0
217:                   ADCON5Lbits.C0PWR = 1; 
0012B2  A80C00     BSET ADCON5L, #0
218:                   while(ADCON5Lbits.C0RDY == 0);
0012B4  000000     NOP
0012B6  806001     MOV ADCON5L, W1
0012B8  201000     MOV #0x100, W0
0012BA  608000     AND W1, W0, W0
0012BC  E00000     CP0 W0
0012BE  32FFFB     BRA Z, .L3
219:                   ADCON3Hbits.C0EN = 1;     
0012C0  A80B0A     BSET ADCON3H, #0
220:               }
0012C2  FA8000     ULNK
0012C4  060000     RETURN
221:               
222:               void ADC1_Core1PowerEnable ( ) 
223:               {
0012C6  FA0000     LNK #0x0
224:                   ADCON5Lbits.C1PWR = 1; 
0012C8  A82C00     BSET ADCON5L, #1
225:                   while(ADCON5Lbits.C1RDY == 0);
0012CA  000000     NOP
0012CC  806001     MOV ADCON5L, W1
0012CE  202000     MOV #0x200, W0
0012D0  608000     AND W1, W0, W0
0012D2  E00000     CP0 W0
0012D4  32FFFB     BRA Z, .L5
226:                   ADCON3Hbits.C1EN = 1;     
0012D6  A82B0A     BSET ADCON3H, #1
227:               }
0012D8  FA8000     ULNK
0012DA  060000     RETURN
228:               
229:               void ADC1_SharedCorePowerEnable ( ) 
230:               {
0012DC  FA0000     LNK #0x0
231:                   ADCON5Lbits.SHRPWR = 1;   
0012DE  A8EC00     BSET ADCON5L, #7
232:                   while(ADCON5Lbits.SHRRDY == 0);
0012E0  000000     NOP
0012E2  806001     MOV ADCON5L, W1
0012E4  280000     MOV #0x8000, W0
0012E6  608000     AND W1, W0, W0
0012E8  E00000     CP0 W0
0012EA  32FFFB     BRA Z, .L7
233:                   ADCON3Hbits.SHREN = 1;   
0012EC  A8EB0A     BSET ADCON3H, #7
234:               }
0012EE  FA8000     ULNK
0012F0  060000     RETURN
235:               
236:               
237:               void __attribute__ ((weak)) ADC1_CallBack ( void )
238:               { 
0012F2  FA0000     LNK #0x0
239:               
240:               }
0012F4  FA8000     ULNK
0012F6  060000     RETURN
241:               
242:               void ADC1_SetCommonInterruptHandler(void* handler)
243:               {
0012F8  FA0002     LNK #0x2
0012FA  780F00     MOV W0, [W14]
244:                   ADC1_CommonDefaultInterruptHandler = handler;
0012FC  78001E     MOV [W14], W0
0012FE  8882F0     MOV W0, ADC1_CommonDefaultInterruptHandler
245:               }
001300  FA8000     ULNK
001302  060000     RETURN
246:               
247:               void __attribute__ ((weak)) ADC1_Tasks ( void )
248:               {
001304  FA0000     LNK #0x0
249:                   if(IFS5bits.ADCIF)
001306  804051     MOV IFS5, W1
001308  204000     MOV #0x400, W0
00130A  608000     AND W1, W0, W0
00130C  E00000     CP0 W0
00130E  320006     BRA Z, .L10
250:                   {
251:                       if(ADC1_CommonDefaultInterruptHandler) 
001310  8082F0     MOV ADC1_CommonDefaultInterruptHandler, W0
001312  E00000     CP0 W0
001314  320002     BRA Z, .L12
252:                       { 
253:                           ADC1_CommonDefaultInterruptHandler(); 
001316  8082F0     MOV ADC1_CommonDefaultInterruptHandler, W0
001318  010000     CALL W0
254:                       }
255:               
256:                       // clear the ADC1 interrupt flag
257:                       IFS5bits.ADCIF = 0;
00131A  A9480B     BCLR 0x80B, #2
258:                   }
259:               }
00131C  FA8000     ULNK
00131E  060000     RETURN
260:               
261:               void __attribute__ ((weak)) ADC1_channel_AN7_CallBack( uint16_t adcVal )
262:               { 
001320  FA0002     LNK #0x2
001322  780F00     MOV W0, [W14]
263:               
264:               }
001324  FA8000     ULNK
001326  060000     RETURN
265:               
266:               void ADC1_Setchannel_AN7InterruptHandler(void* handler)
267:               {
001328  FA0002     LNK #0x2
00132A  780F00     MOV W0, [W14]
268:                   ADC1_channel_AN7DefaultInterruptHandler = handler;
00132C  78001E     MOV [W14], W0
00132E  888300     MOV W0, ADC1_channel_AN7DefaultInterruptHandler
269:               }
001330  FA8000     ULNK
001332  060000     RETURN
270:               
271:               void __attribute__ ((weak)) ADC1_channel_AN7_Tasks ( void )
272:               {
001334  FA0002     LNK #0x2
273:                   uint16_t valchannel_AN7;
274:               
275:                   if(ADSTATLbits.AN7RDY)
001336  805981     MOV ADSTATL, W1
001338  200800     MOV #0x80, W0
00133A  608000     AND W1, W0, W0
00133C  E00000     CP0 W0
00133E  320008     BRA Z, .L15
276:                   {
277:                       //Read the ADC value from the ADCBUF
278:                       valchannel_AN7 = ADCBUF7;
001340  8060D1     MOV ADCBUF7, W1
001342  780F01     MOV W1, [W14]
279:               
280:                       if(ADC1_channel_AN7DefaultInterruptHandler) 
001344  808300     MOV ADC1_channel_AN7DefaultInterruptHandler, W0
001346  E00000     CP0 W0
001348  320003     BRA Z, .L15
281:                       { 
282:                           ADC1_channel_AN7DefaultInterruptHandler(valchannel_AN7); 
00134A  808301     MOV ADC1_channel_AN7DefaultInterruptHandler, W1
00134C  78001E     MOV [W14], W0
00134E  010001     CALL W1
283:                       }
284:                   }
285:               }
001350  FA8000     ULNK
001352  060000     RETURN
286:               
287:               void __attribute__ ((weak)) ADC1_channel_AN12_CallBack( uint16_t adcVal )
288:               { 
001354  FA0002     LNK #0x2
001356  780F00     MOV W0, [W14]
289:               
290:               }
001358  FA8000     ULNK
00135A  060000     RETURN
291:               
292:               void ADC1_Setchannel_AN12InterruptHandler(void* handler)
293:               {
00135C  FA0002     LNK #0x2
00135E  780F00     MOV W0, [W14]
294:                   ADC1_channel_AN12DefaultInterruptHandler = handler;
001360  78001E     MOV [W14], W0
001362  888310     MOV W0, ADC1_channel_AN12DefaultInterruptHandler
295:               }
001364  FA8000     ULNK
001366  060000     RETURN
296:               
297:               void __attribute__ ((weak)) ADC1_channel_AN12_Tasks ( void )
298:               {
001368  FA0002     LNK #0x2
299:                   uint16_t valchannel_AN12;
300:               
301:                   if(ADSTATLbits.AN12RDY)
00136A  805981     MOV ADSTATL, W1
00136C  210000     MOV #0x1000, W0
00136E  608000     AND W1, W0, W0
001370  E00000     CP0 W0
001372  320008     BRA Z, .L19
302:                   {
303:                       //Read the ADC value from the ADCBUF
304:                       valchannel_AN12 = ADCBUF12;
001374  806121     MOV ADCBUF12, W1
001376  780F01     MOV W1, [W14]
305:               
306:                       if(ADC1_channel_AN12DefaultInterruptHandler) 
001378  808310     MOV ADC1_channel_AN12DefaultInterruptHandler, W0
00137A  E00000     CP0 W0
00137C  320003     BRA Z, .L19
307:                       { 
308:                           ADC1_channel_AN12DefaultInterruptHandler(valchannel_AN12); 
00137E  808311     MOV ADC1_channel_AN12DefaultInterruptHandler, W1
001380  78001E     MOV [W14], W0
001382  010001     CALL W1
309:                       }
310:                   }
311:               }
001384  FA8000     ULNK
001386  060000     RETURN
312:               
313:               void __attribute__ ((weak)) ADC1_channel_AN15_CallBack( uint16_t adcVal )
314:               { 
001388  FA0002     LNK #0x2
00138A  780F00     MOV W0, [W14]
315:               
316:               }
00138C  FA8000     ULNK
00138E  060000     RETURN
317:               
318:               void ADC1_Setchannel_AN15InterruptHandler(void* handler)
319:               {
001390  FA0002     LNK #0x2
001392  780F00     MOV W0, [W14]
320:                   ADC1_channel_AN15DefaultInterruptHandler = handler;
001394  78001E     MOV [W14], W0
001396  888320     MOV W0, ADC1_channel_AN15DefaultInterruptHandler
321:               }
001398  FA8000     ULNK
00139A  060000     RETURN
322:               
323:               void __attribute__ ((weak)) ADC1_channel_AN15_Tasks ( void )
324:               {
00139C  FA0002     LNK #0x2
325:                   uint16_t valchannel_AN15;
326:               
327:                   if(ADSTATLbits.AN15RDY)
00139E  805981     MOV ADSTATL, W1
0013A0  280000     MOV #0x8000, W0
0013A2  608000     AND W1, W0, W0
0013A4  E00000     CP0 W0
0013A6  320008     BRA Z, .L23
328:                   {
329:                       //Read the ADC value from the ADCBUF
330:                       valchannel_AN15 = ADCBUF15;
0013A8  806151     MOV ADCBUF15, W1
0013AA  780F01     MOV W1, [W14]
331:               
332:                       if(ADC1_channel_AN15DefaultInterruptHandler) 
0013AC  808320     MOV ADC1_channel_AN15DefaultInterruptHandler, W0
0013AE  E00000     CP0 W0
0013B0  320003     BRA Z, .L23
333:                       { 
334:                           ADC1_channel_AN15DefaultInterruptHandler(valchannel_AN15); 
0013B2  808321     MOV ADC1_channel_AN15DefaultInterruptHandler, W1
0013B4  78001E     MOV [W14], W0
0013B6  010001     CALL W1
335:                       }
336:                   }
337:               }
0013B8  FA8000     ULNK
0013BA  060000     RETURN
338:               
339:               void __attribute__ ((weak)) ADC1_channel_AN17_CallBack( uint16_t adcVal )
340:               { 
0013BC  FA0002     LNK #0x2
0013BE  780F00     MOV W0, [W14]
341:               
342:               }
0013C0  FA8000     ULNK
0013C2  060000     RETURN
343:               
344:               void ADC1_Setchannel_AN17InterruptHandler(void* handler)
345:               {
0013C4  FA0002     LNK #0x2
0013C6  780F00     MOV W0, [W14]
346:                   ADC1_channel_AN17DefaultInterruptHandler = handler;
0013C8  78001E     MOV [W14], W0
0013CA  888330     MOV W0, ADC1_channel_AN17DefaultInterruptHandler
347:               }
0013CC  FA8000     ULNK
0013CE  060000     RETURN
348:               
349:               void __attribute__ ( ( __interrupt__ , auto_psv, weak ) ) _ADCAN17Interrupt ( void )
350:               {
000316  F80036     PUSH RCOUNT
000318  BE9F80     MOV.D W0, [W15++]
00031A  BE9F82     MOV.D W2, [W15++]
00031C  BE9F84     MOV.D W4, [W15++]
00031E  BE9F86     MOV.D W6, [W15++]
000320  F80032     PUSH DSRPAG
000322  F80034     PUSH DSWPAG
000324  200010     MOV #0x1, W0
000326  8801A0     MOV W0, DSWPAG
000328  200010     MOV #0x1, W0
00032A  FED000     MOVPAG W0, DSRPAG
00032C  FA0002     LNK #0x2
351:                   uint16_t valchannel_AN17;
352:                   //Read the ADC value from the ADCBUF
353:                   valchannel_AN17 = ADCBUF17;
00032E  806171     MOV ADCBUF17, W1
000330  780F01     MOV W1, [W14]
354:               
355:                   if(ADC1_channel_AN17DefaultInterruptHandler) 
000332  808330     MOV ADC1_channel_AN17DefaultInterruptHandler, W0
000334  E00000     CP0 W0
000336  320003     BRA Z, .L28
356:                   { 
357:                       ADC1_channel_AN17DefaultInterruptHandler(valchannel_AN17); 
000338  808331     MOV ADC1_channel_AN17DefaultInterruptHandler, W1
00033A  78001E     MOV [W14], W0
00033C  010001     CALL W1
358:                   }
359:               
360:                   //clear the channel_AN17 interrupt flag
361:                   IFS6bits.ADCAN17IF = 0;
00033E  A9880D     BCLR 0x80D, #4
362:               }
000340  FA8000     ULNK
000342  F90034     POP DSWPAG
000344  F90032     POP DSRPAG
000346  BE034F     MOV.D [--W15], W6
000348  BE024F     MOV.D [--W15], W4
00034A  BE014F     MOV.D [--W15], W2
00034C  BE004F     MOV.D [--W15], W0
00034E  F90036     POP RCOUNT
000350  064000     RETFIE
363:               
364:               void __attribute__ ((weak)) ADC1_channel_AN19_CallBack( uint16_t adcVal )
365:               { 
0013D0  FA0002     LNK #0x2
0013D2  780F00     MOV W0, [W14]
366:               
367:               }
0013D4  FA8000     ULNK
0013D6  060000     RETURN
368:               
369:               void ADC1_Setchannel_AN19InterruptHandler(void* handler)
370:               {
0013D8  FA0002     LNK #0x2
0013DA  780F00     MOV W0, [W14]
371:                   ADC1_channel_AN19DefaultInterruptHandler = handler;
0013DC  78001E     MOV [W14], W0
0013DE  888340     MOV W0, ADC1_channel_AN19DefaultInterruptHandler
372:               }
0013E0  FA8000     ULNK
0013E2  060000     RETURN
373:               
374:               void __attribute__ ( ( __interrupt__ , auto_psv, weak ) ) _ADCAN19Interrupt ( void )
375:               {
000352  F80036     PUSH RCOUNT
000354  BE9F80     MOV.D W0, [W15++]
000356  BE9F82     MOV.D W2, [W15++]
000358  BE9F84     MOV.D W4, [W15++]
00035A  BE9F86     MOV.D W6, [W15++]
00035C  F80032     PUSH DSRPAG
00035E  F80034     PUSH DSWPAG
000360  200010     MOV #0x1, W0
000362  8801A0     MOV W0, DSWPAG
000364  200010     MOV #0x1, W0
000366  FED000     MOVPAG W0, DSRPAG
000368  FA0002     LNK #0x2
376:                   uint16_t valchannel_AN19;
377:                   //Read the ADC value from the ADCBUF
378:                   valchannel_AN19 = ADCBUF19;
00036A  806191     MOV ADCBUF19, W1
00036C  780F01     MOV W1, [W14]
379:               
380:                   if(ADC1_channel_AN19DefaultInterruptHandler) 
00036E  808340     MOV ADC1_channel_AN19DefaultInterruptHandler, W0
000370  E00000     CP0 W0
000372  320003     BRA Z, .L32
381:                   { 
382:                       ADC1_channel_AN19DefaultInterruptHandler(valchannel_AN19); 
000374  808341     MOV ADC1_channel_AN19DefaultInterruptHandler, W1
000376  78001E     MOV [W14], W0
000378  010001     CALL W1
383:                   }
384:               
385:                   //clear the channel_AN19 interrupt flag
386:                   IFS6bits.ADCAN19IF = 0;
00037A  A9C80D     BCLR 0x80D, #6
387:               }
00037C  FA8000     ULNK
00037E  F90034     POP DSWPAG
000380  F90032     POP DSRPAG
000382  BE034F     MOV.D [--W15], W6
000384  BE024F     MOV.D [--W15], W4
000386  BE014F     MOV.D [--W15], W2
000388  BE004F     MOV.D [--W15], W0
00038A  F90036     POP RCOUNT
00038C  064000     RETFIE
388:               
389:               void __attribute__ ((weak)) ADC1_channel_AN20_CallBack( uint16_t adcVal )
390:               { 
0013E4  FA0002     LNK #0x2
0013E6  780F00     MOV W0, [W14]
391:               
392:               }
0013E8  FA8000     ULNK
0013EA  060000     RETURN
393:               
394:               void ADC1_Setchannel_AN20InterruptHandler(void* handler)
395:               {
0013EC  FA0002     LNK #0x2
0013EE  780F00     MOV W0, [W14]
396:                   ADC1_channel_AN20DefaultInterruptHandler = handler;
0013F0  78001E     MOV [W14], W0
0013F2  888350     MOV W0, ADC1_channel_AN20DefaultInterruptHandler
397:               }
0013F4  FA8000     ULNK
0013F6  060000     RETURN
398:               
399:               void __attribute__ ( ( __interrupt__ , auto_psv, weak ) ) _ADCAN20Interrupt ( void )
400:               {
00038E  F80036     PUSH RCOUNT
000390  BE9F80     MOV.D W0, [W15++]
000392  BE9F82     MOV.D W2, [W15++]
000394  BE9F84     MOV.D W4, [W15++]
000396  BE9F86     MOV.D W6, [W15++]
000398  F80032     PUSH DSRPAG
00039A  F80034     PUSH DSWPAG
00039C  200010     MOV #0x1, W0
00039E  8801A0     MOV W0, DSWPAG
0003A0  200010     MOV #0x1, W0
0003A2  FED000     MOVPAG W0, DSRPAG
0003A4  FA0002     LNK #0x2
401:                   uint16_t valchannel_AN20;
402:                   //Read the ADC value from the ADCBUF
403:                   valchannel_AN20 = ADCBUF20;
0003A6  8061A1     MOV ADCBUF20, W1
0003A8  780F01     MOV W1, [W14]
404:               
405:                   if(ADC1_channel_AN20DefaultInterruptHandler) 
0003AA  808350     MOV ADC1_channel_AN20DefaultInterruptHandler, W0
0003AC  E00000     CP0 W0
0003AE  320003     BRA Z, .L36
406:                   { 
407:                       ADC1_channel_AN20DefaultInterruptHandler(valchannel_AN20); 
0003B0  808351     MOV ADC1_channel_AN20DefaultInterruptHandler, W1
0003B2  78001E     MOV [W14], W0
0003B4  010001     CALL W1
408:                   }
409:               
410:                   //clear the channel_AN20 interrupt flag
411:                   IFS6bits.ADCAN20IF = 0;
0003B6  A9E80D     BCLR 0x80D, #7
412:               }
0003B8  FA8000     ULNK
0003BA  F90034     POP DSWPAG
0003BC  F90032     POP DSRPAG
0003BE  BE034F     MOV.D [--W15], W6
0003C0  BE024F     MOV.D [--W15], W4
0003C2  BE014F     MOV.D [--W15], W2
0003C4  BE004F     MOV.D [--W15], W0
0003C6  F90036     POP RCOUNT
0003C8  064000     RETFIE
413:               
414:               
415:               
416:               
417:               /**
418:                 End of File
419:               */
---  C:/Users/NapAp/Documents/Ecole/M2/Q1/Projet/Software/E_Comet_All_ADC_PWM_OPAMP/main.c  -------------
1:                 /*
2:                  * Projet Shell Eco-Marathon 2024
3:                  * 
4:                  * Ecole d'Ingnieurs de Pierrard-Virton
5:                  * 
6:                  */
7:                 
8:                 // Dfinition de variables globales
9:                 #define FCY 8000000UL // dfini la fonction : __delay_ms()
10:                #define CYCLE_DELAY 10
11:                
12:                // Nos librairies
13:                #include "mcc_generated_files/system.h"
14:                #include "mcc_generated_files/pwm.h"
15:                #include "mcc_generated_files/adc1.h"
16:                #include "lib_ecomet.h"
17:                
18:                // Autres librairies
19:                #include <libpic30.h> //Defines __delay32();
20:                #include <math.h>
21:                
22:                // Programme
23:                int main(void){
24:                    
25:                    init_Ecomet();
26:                    
27:                    // Indique que la carte a fini son initialisation
28:                    
29:                    changeDC_Buzzer(0x00); // DC = 0 %
30:                    __delay_ms(1000);
31:                    changeDC_Buzzer(0x271); // DC = 50 %
32:                    __delay_ms(1000);
33:                    changeDC_Buzzer(0x00); // DC = 0 %
34:                    __delay_ms(1000);
35:                    changeDC_Buzzer(0x271); // DC = 50 %
36:                    __delay_ms(1000);
37:                    changeDC_Buzzer(0x00); // DC = 0 %
38:                     
0017FC  FA0000     LNK #0x0
39:                    while (1){
40:                        changeDC_Motor();
0017FE  07FCD4     RCALL init_Ecomet
41:                        
42:                        measureVBUS();
43:                        measureTempMOSFET();
44:                    }
001800  EB0000     CLR W0
001802  07FBD6     RCALL changeDC_Buzzer
45:                    return 1; 
001804  212000     MOV #0x1200, W0
001806  2007A1     MOV #0x7A, W1
001808  07005B     RCALL ___delay32, .Letext0, .LFE0
46:                }
00180A  202710     MOV #0x271, W0
00180C  07FBD1     RCALL changeDC_Buzzer
00180E  212000     MOV #0x1200, W0
001810  2007A1     MOV #0x7A, W1
001812  070056     RCALL ___delay32, .Letext0, .LFE0
001814  EB0000     CLR W0
001816  07FBCC     RCALL changeDC_Buzzer
001818  212000     MOV #0x1200, W0
00181A  2007A1     MOV #0x7A, W1
00181C  070051     RCALL ___delay32, .Letext0, .LFE0
00181E  202710     MOV #0x271, W0
001820  07FBC7     RCALL changeDC_Buzzer
001822  212000     MOV #0x1200, W0
001824  2007A1     MOV #0x7A, W1
001826  07004C     RCALL ___delay32, .Letext0, .LFE0
001828  EB0000     CLR W0
00182A  07FBC2     RCALL changeDC_Buzzer
00182C  07FB7C     RCALL changeDC_Motor
00182E  07FC3A     RCALL measureVBUS
001830  07FC09     RCALL measureShunt_2
001832  07FC6B     RCALL measureTempMOSFET
001834  37FFFB     BRA .L2
---  C:/Users/NapAp/Documents/Ecole/M2/Q1/Projet/Software/E_Comet_All_ADC_PWM_OPAMP/lib_ecomet.c  -------
1:                 /*
2:                  * Projet Shell Eco-Marathon 2024
3:                  * 
4:                  * Ecole d'Ingnieurs de Pierrard-Virton
5:                  * 
6:                  */
7:                 
8:                 // Dfinition de variables globales
9:                 #define FCY 8000000UL // dfini la fonction : __delay_ms()
10:                #define CYCLE_DELAY 10
11:                
12:                // Nos librairies
13:                #include "mcc_generated_files/system.h"
14:                #include "mcc_generated_files/pwm.h"
15:                #include "mcc_generated_files/adc1.h"
16:                
17:                // Autres librairies
18:                #include <libpic30.h> //Defines __delay32();
19:                #include <math.h>
20:                
21:                // AN17 : potentiomtre             --> acclrateur
22:                // AN12 : temprature               --> temprature MOSFET Q2
23:                // AN15 : VBUS                      --> tension batterie
24:                // AN0 : OA1out                     --> courant moteur
25:                // AN7 : OA2_out = Shunt_norm+      --> courant batterie
26:                
27:                int DC_Motor = 0x00;
28:                double Rshunt = 0.002;
29:                float VBUS = 0;
000F26  FA0006     LNK #0x6
30:                float courantBatt = 0;
31:                float temp = 0;
000F28  200040     MOV #0x4, W0
000F2A  980710     MOV W0, [W14+2]
32:                
33:                // Tension de rfrence
000F2C  EB0000     CLR W0
000F2E  980720     MOV W0, [W14+4]
34:                float Ualim = 3.3;
000F30  EB0000     CLR W0
000F32  780F00     MOV W0, [W14]
35:                
36:                // Tous les ADCs sont en 12 bit
000F34  070158     RCALL ADC1_Initialize
37:                
38:                void changeDC_Motor(){                                                          // Change le DC du Buck de puissance via la lecture du potentiomtre
000F36  07FF69     RCALL _ADC1_Enable, .LFE24, .LFB46
39:                
000F38  90001E     MOV [W14+2], W0
000F3A  07FF77     RCALL _ADC1_ChannelSelect, .LFE49, .LFB50
40:                    ADC1_CHANNEL channel = channel_AN17; // lit la pin RC6 o est connect le potentiomtre
000F3C  07FF6E     RCALL _ADC1_SoftwareTriggerEnable, .LFE47, .LFB48
41:                            
42:                    int conversion = 0;
000F3E  EB0000     CLR W0
000F40  780F00     MOV W0, [W14]
000F42  370001     BRA .L47
000F44  E80F1E     INC [W14], [W14]
000F46  203E70     MOV #0x3E7, W0
000F48  78009E     MOV [W14], W1
000F4A  508F80     SUB W1, W0, [W15]
000F4C  34FFFB     BRA LE, .L48
43:                    int i=0;
44:                    
45:                    ADC1_Initialize();
46:                
000F4E  07FF69     RCALL _ADC1_SoftwareTriggerDisable, .LFE48, .LFB49
47:                    ADC1_Enable();
48:                    ADC1_ChannelSelect(channel);
000F50  90001E     MOV [W14+2], W0
000F52  07FF6F     RCALL _ADC1_ConversionResultGet, .LFE50, .LFB51
000F54  2FBFB1     MOV #0xFBFB, W1
000F56  400001     ADD W0, W1, W0
000F58  980720     MOV W0, [W14+4]
49:                    ADC1_SoftwareTriggerEnable();
000F5A  07FF5B     RCALL _ADC1_Disable, .LFE46, .LFB47
50:                    
51:                    for(i=0;i <1000;i++) // laisse le temps au PIC de faire la mesure
000F5C  90002E     MOV [W14+4], W0
000F5E  DE80CF     ASR W0, #15, W1
000F60  07FAC6     RCALL ___floatsisf
000F62  2F0002     MOV #0xF000, W2
000F64  2457F3     MOV #0x457F, W3
000F66  07FBC9     RCALL ___divsf3, ___divsf3x
000F68  200002     MOV #0x0, W2
000F6A  243473     MOV #0x4347, W3
000F6C  07FCA5     RCALL ___mulsf3x, ___mulsf3
000F6E  BE0200     MOV.D W0, W4
000F70  808380     MOV 0x1070, W0
000F72  808391     MOV 0x1072, W1
000F74  BE0100     MOV.D W0, W2
000F76  BE0004     MOV.D W4, W0
000F78  07FC9F     RCALL ___mulsf3x, ___mulsf3
000F7A  2CCCD2     MOV #0xCCCD, W2
000F7C  23FDC3     MOV #0x3FDC, W3
000F7E  07FBBD     RCALL ___divsf3, ___divsf3x
000F80  07FE88     RCALL _roundf
000F82  07FA94     RCALL ___fixsfsi
000F84  780000     MOV W0, W0
000F86  A7F000     BTSC W0, #15
000F88  EA0000     NEG W0, W0
000F8A  888280     MOV W0, DC_Motor
52:                    {
53:                    }
000F8C  808280     MOV DC_Motor, W0
000F8E  780080     MOV W0, W1
000F90  200010     MOV #0x1, W0
000F92  07FF08     RCALL _PWM_DutyCycleSet, .LFE12, .LFB13
54:                    
000F94  200080     MOV #0x8, W0
000F96  881970     MOV W0, PG1STAT
55:                    ADC1_SoftwareTriggerDisable();
000F98  FA8000     ULNK
000F9A  060000     RETURN
56:                    //while(!ADC1_IsConversionComplete(channel));
57:                    conversion = ADC1_ConversionResultGet(channel) - 1050; // Corrige le dcallage 
000F9C  FA0002     LNK #0x2
000F9E  780F00     MOV W0, [W14]
58:                                                                           // de tension du potentiomtre
59:                    ADC1_Disable(); 
000FA0  78001E     MOV [W14], W0
000FA2  780080     MOV W0, W1
000FA4  200010     MOV #0x1, W0
000FA6  07FEED     RCALL _PWM_PeriodSet, .Ltext0, .LFB12
60:                    
000FA8  200080     MOV #0x8, W0
000FAA  881970     MOV W0, PG1STAT
61:                    DC_Motor = abs(round((float)(conversion/4095.0)*150.0*Ualim/1.725));
000FAC  FA8000     ULNK
000FAE  060000     RETURN
62:                     
63:                    PWM_DutyCycleSet(PWM_GENERATOR_1, DC_Motor);
000FB0  FA0002     LNK #0x2
000FB2  780F00     MOV W0, [W14]
64:                    PG1STAT = 0b01000;
65:                }
000FB4  78001E     MOV [W14], W0
000FB6  780080     MOV W0, W1
000FB8  200030     MOV #0x3, W0
000FBA  07FEF4     RCALL _PWM_DutyCycleSet, .LFE12, .LFB13
66:                
000FBC  200080     MOV #0x8, W0
000FBE  881CD0     MOV W0, PG3STAT
67:                void changeFreq_Motor(int freq_Motor){                                          // Change la frquence du Buck de puissance de manire manuelle
000FC0  FA8000     ULNK
000FC2  060000     RETURN
68:                    
69:                    PWM_PeriodSet(PWM_GENERATOR_1, freq_Motor);
000FC4  FA0002     LNK #0x2
000FC6  780F00     MOV W0, [W14]
70:                    PG1STAT = 0b01000;
71:                }
000FC8  78001E     MOV [W14], W0
000FCA  780080     MOV W0, W1
000FCC  200030     MOV #0x3, W0
000FCE  07FED9     RCALL _PWM_PeriodSet, .Ltext0, .LFB12
72:                
000FD0  200080     MOV #0x8, W0
000FD2  881CD0     MOV W0, PG3STAT
73:                void changeDC_Buzzer(int DC_Buzzer){                                            // Change le DC du buzzer de manire manuelle
000FD4  FA8000     ULNK
000FD6  060000     RETURN
74:                    
75:                    PWM_DutyCycleSet(PWM_GENERATOR_3, DC_Buzzer); 
000FD8  FA0006     LNK #0x6
76:                    PG3STAT = 0b01000;
77:                }
000FDA  200010     MOV #0x1, W0
000FDC  980710     MOV W0, [W14+2]
78:                
79:                void changeFreq_Buzzer(int freq_Buzzer){                                        // Change la frquence de l'alimentation du buzzer de manire manuelle
000FDE  EB0000     CLR W0
000FE0  980720     MOV W0, [W14+4]
80:                
000FE2  EB0000     CLR W0
000FE4  780F00     MOV W0, [W14]
81:                    PWM_PeriodSet(PWM_GENERATOR_3, freq_Buzzer);
82:                    PG3STAT = 0b01000;
000FE6  0700FF     RCALL ADC1_Initialize
83:                }
84:                
000FE8  07FF10     RCALL _ADC1_Enable, .LFE24, .LFB46
85:                void measureShunt_1(){                                                          // Mesure le courant fourni par la batterie
000FEA  90001E     MOV [W14+2], W0
000FEC  07FF1E     RCALL _ADC1_ChannelSelect, .LFE49, .LFB50
86:                    
000FEE  07FF15     RCALL _ADC1_SoftwareTriggerEnable, .LFE47, .LFB48
87:                    ADC1_CHANNEL channel = channel_AN7; 
88:                            
000FF0  EB0000     CLR W0
000FF2  780F00     MOV W0, [W14]
000FF4  370001     BRA .L53
000FF6  E80F1E     INC [W14], [W14]
000FF8  203E70     MOV #0x3E7, W0
000FFA  78009E     MOV [W14], W1
000FFC  508F80     SUB W1, W0, [W15]
000FFE  34FFFB     BRA LE, .L54
89:                    int conversion = 0;
90:                    int i=0;
91:                    
92:                    ADC1_Initialize();
001000  07FF10     RCALL _ADC1_SoftwareTriggerDisable, .LFE48, .LFB49
93:                
001002  000000     NOP
001004  90001E     MOV [W14+2], W0
001006  07FF3D     RCALL _ADC1_IsConversionComplete, .LFE51, .LFB52
001008  A20400     BTG.B W0, #0
00100A  E00400     CP0.B W0
00100C  3AFFFB     BRA NZ, .L55
94:                    ADC1_Enable();
00100E  90001E     MOV [W14+2], W0
001010  07FF10     RCALL _ADC1_ConversionResultGet, .LFE50, .LFB51
001012  980720     MOV W0, [W14+4]
95:                    ADC1_ChannelSelect(channel);
001014  07FEFE     RCALL _ADC1_Disable, .LFE46, .LFB47
96:                    ADC1_SoftwareTriggerEnable();
001016  9000AE     MOV [W14+4], W1
001018  20FFF0     MOV #0xFFF, W0
00101A  780100     MOV W0, W2
00101C  090005     REPEAT #0x5
00101E  D80082     DIV.SW W1, W2
001020  DE80CF     ASR W0, #15, W1
001022  07FA65     RCALL ___floatsisf
001024  BE0200     MOV.D W0, W4
001026  808380     MOV 0x1070, W0
001028  808391     MOV 0x1072, W1
00102A  BE0100     MOV.D W0, W2
00102C  BE0004     MOV.D W4, W0
00102E  07FC44     RCALL ___mulsf3x, ___mulsf3
001030  BE0200     MOV.D W0, W4
001032  808360     MOV 0x106C, W0
001034  808371     MOV 0x106E, W1
001036  BE0100     MOV.D W0, W2
001038  BE0004     MOV.D W4, W0
00103A  07FB5F     RCALL ___divsf3, ___divsf3x
00103C  8882B0     MOV W0, courantBatt
00103E  8882C1     MOV W1, 0x1058
97:                    
001040  FA8000     ULNK
001042  060000     RETURN
98:                    for(i=0;i <1000;i++) // laisse le temps au PIC de faire la mesure
99:                    {
001044  FA0006     LNK #0x6
100:                   }
101:                   
001046  EB0000     CLR W0
001048  980710     MOV W0, [W14+2]
102:                   ADC1_SoftwareTriggerDisable();
103:                   while(!ADC1_IsConversionComplete(channel));
00104A  EB0000     CLR W0
00104C  980720     MOV W0, [W14+4]
104:                   conversion = ADC1_ConversionResultGet(channel); 
00104E  EB0000     CLR W0
001050  780F00     MOV W0, [W14]
105:                   ADC1_Disable();
106:                   courantBatt = (float)(conversion/4095*Ualim/Rshunt);
001052  0700C9     RCALL ADC1_Initialize
107:               }
108:               
001054  07FEDA     RCALL _ADC1_Enable, .LFE24, .LFB46
109:               void measureShunt_2(){ // Mesure le courant absorb par le moteur
001056  90001E     MOV [W14+2], W0
001058  07FEE8     RCALL _ADC1_ChannelSelect, .LFE49, .LFB50
110:                   // Poser question monsieur Alaime
00105A  07FEDF     RCALL _ADC1_SoftwareTriggerEnable, .LFE47, .LFB48
111:               }
112:               
00105C  EB0000     CLR W0
00105E  780F00     MOV W0, [W14]
001060  370001     BRA .L57
001062  E80F1E     INC [W14], [W14]
001064  203E70     MOV #0x3E7, W0
001066  78009E     MOV [W14], W1
001068  508F80     SUB W1, W0, [W15]
00106A  34FFFB     BRA LE, .L58
113:               void measureVBUS(){                                                             // Mesure la tension de la batterie (les 3 4S en srie)
114:                   
115:                   ADC1_CHANNEL channel = channel_AN15; 
116:                           
00106C  07FEDA     RCALL _ADC1_SoftwareTriggerDisable, .LFE48, .LFB49
117:                   int conversion = 0;
118:                   int i=0;
00106E  90001E     MOV [W14+2], W0
001070  07FEE0     RCALL _ADC1_ConversionResultGet, .LFE50, .LFB51
001072  980720     MOV W0, [W14+4]
119:                   
001074  07FECE     RCALL _ADC1_Disable, .LFE46, .LFB47
120:                   ADC1_Initialize();
001076  9000AE     MOV [W14+4], W1
001078  20FFF0     MOV #0xFFF, W0
00107A  780100     MOV W0, W2
00107C  090005     REPEAT #0x5
00107E  D80082     DIV.SW W1, W2
001080  DE80CF     ASR W0, #15, W1
001082  07FA35     RCALL ___floatsisf
001084  BE0200     MOV.D W0, W4
001086  808380     MOV 0x1070, W0
001088  808391     MOV 0x1072, W1
00108A  BE0100     MOV.D W0, W2
00108C  BE0004     MOV.D W4, W0
00108E  07FC14     RCALL ___mulsf3x, ___mulsf3
001090  BE0200     MOV.D W0, W4
001092  808360     MOV 0x106C, W0
001094  808371     MOV 0x106E, W1
001096  BE0100     MOV.D W0, W2
001098  BE0004     MOV.D W4, W0
00109A  07FB2F     RCALL ___divsf3, ___divsf3x
00109C  8882B0     MOV W0, courantBatt
00109E  8882C1     MOV W1, 0x1058
121:               
0010A0  FA8000     ULNK
0010A2  060000     RETURN
122:                   ADC1_Enable();
123:                   ADC1_ChannelSelect(channel);
0010A4  FA0006     LNK #0x6
124:                   ADC1_SoftwareTriggerEnable();
125:                   
0010A6  200030     MOV #0x3, W0
0010A8  980710     MOV W0, [W14+2]
126:                   for(i=0;i <1000;i++) // laisse le temps au PIC de faire la mesure
127:                   {
0010AA  EB0000     CLR W0
0010AC  980720     MOV W0, [W14+4]
128:                   }
0010AE  EB0000     CLR W0
0010B0  780F00     MOV W0, [W14]
129:                   
130:                   ADC1_SoftwareTriggerDisable();
0010B2  070099     RCALL ADC1_Initialize
131:                   while(!ADC1_IsConversionComplete(channel));
132:                   conversion = ADC1_ConversionResultGet(channel); 
0010B4  07FEAA     RCALL _ADC1_Enable, .LFE24, .LFB46
133:                   ADC1_Disable();
0010B6  90001E     MOV [W14+2], W0
0010B8  07FEB8     RCALL _ADC1_ChannelSelect, .LFE49, .LFB50
134:                   VBUS = (float)(conversion/4095.0*Ualim*16.0); 
0010BA  07FEAF     RCALL _ADC1_SoftwareTriggerEnable, .LFE47, .LFB48
135:               }
136:               
0010BC  EB0000     CLR W0
0010BE  780F00     MOV W0, [W14]
0010C0  370001     BRA .L60
0010C2  E80F1E     INC [W14], [W14]
0010C4  203E70     MOV #0x3E7, W0
0010C6  78009E     MOV [W14], W1
0010C8  508F80     SUB W1, W0, [W15]
0010CA  34FFFB     BRA LE, .L61
137:               void measureTempMOSFET(){                                                       // Mesure la temprature de la surface du MOSFET Q2
138:                   
139:                   ADC1_CHANNEL channel = channel_AN12;  
140:                                                        
0010CC  07FEAA     RCALL _ADC1_SoftwareTriggerDisable, .LFE48, .LFB49
141:                   int conversion = 0;
0010CE  000000     NOP
0010D0  90001E     MOV [W14+2], W0
0010D2  07FED7     RCALL _ADC1_IsConversionComplete, .LFE51, .LFB52
0010D4  A20400     BTG.B W0, #0
0010D6  E00400     CP0.B W0
0010D8  3AFFFB     BRA NZ, .L62
142:                   int i=0;
0010DA  90001E     MOV [W14+2], W0
0010DC  07FEAA     RCALL _ADC1_ConversionResultGet, .LFE50, .LFB51
0010DE  980720     MOV W0, [W14+4]
143:                   double Uout = 0;
0010E0  07FE98     RCALL _ADC1_Disable, .LFE46, .LFB47
144:                   double Rth = 0;
0010E2  9000AE     MOV [W14+4], W1
0010E4  20FFF0     MOV #0xFFF, W0
0010E6  780100     MOV W0, W2
0010E8  090005     REPEAT #0x5
0010EA  D80082     DIV.SW W1, W2
0010EC  DE80CF     ASR W0, #15, W1
0010EE  07F9FF     RCALL ___floatsisf
0010F0  BE0200     MOV.D W0, W4
0010F2  808380     MOV 0x1070, W0
0010F4  808391     MOV 0x1072, W1
0010F6  BE0100     MOV.D W0, W2
0010F8  BE0004     MOV.D W4, W0
0010FA  07FBDE     RCALL ___mulsf3x, ___mulsf3
0010FC  200002     MOV #0x0, W2
0010FE  241803     MOV #0x4180, W3
001100  07FBDB     RCALL ___mulsf3x, ___mulsf3
001102  888290     MOV W0, VBUS
001104  8882A1     MOV W1, 0x1054
145:                   
001106  FA8000     ULNK
001108  060000     RETURN
146:                   int R2 = 3300; // Rsitance du pont diviseur de la mesure de temprature
147:                   
00110A  FA0010     LNK #0x10
00110C  BE9F88     MOV.D W8, [W15++]
148:                   ADC1_Initialize();
149:               
00110E  200020     MOV #0x2, W0
001110  980710     MOV W0, [W14+2]
150:                   ADC1_Enable();
151:                   ADC1_ChannelSelect(channel);
001112  EB0000     CLR W0
001114  980720     MOV W0, [W14+4]
152:                   ADC1_SoftwareTriggerEnable();
001116  EB0000     CLR W0
001118  780F00     MOV W0, [W14]
153:                   
00111A  B80060     MUL.UU W0, #0x0, W0
00111C  980730     MOV W0, [W14+6]
00111E  980741     MOV W1, [W14+8]
154:                   for(i=0;i <1000;i++) // laisse le temps au PIC de faire la mesure
001120  B80060     MUL.UU W0, #0x0, W0
001122  980750     MOV W0, [W14+10]
001124  980761     MOV W1, [W14+12]
155:                   {
156:                   }
001126  20CE40     MOV #0xCE4, W0
001128  980770     MOV W0, [W14+14]
157:                   
158:                   ADC1_SoftwareTriggerDisable();
00112A  07005D     RCALL ADC1_Initialize
159:                   while(!ADC1_IsConversionComplete(channel));
160:                   conversion = ADC1_ConversionResultGet(channel); 
00112C  07FE6E     RCALL _ADC1_Enable, .LFE24, .LFB46
161:                   ADC1_Disable();
00112E  90001E     MOV [W14+2], W0
001130  07FE7C     RCALL _ADC1_ChannelSelect, .LFE49, .LFB50
162:                   Uout = (float)(conversion/4095.0*Ualim);
001132  07FE73     RCALL _ADC1_SoftwareTriggerEnable, .LFE47, .LFB48
163:                   Rth = R2*Uout/(Ualim - Uout);
164:                   temp = 82.313*pow(Rth/10000.0,-0.235) - 56.0; // Utilisation de la fonction de rgression 
001134  EB0000     CLR W0
001136  780F00     MOV W0, [W14]
001138  370001     BRA .L64
00113A  E80F1E     INC [W14], [W14]
00113C  203E70     MOV #0x3E7, W0
00113E  78009E     MOV [W14], W1
001140  508F80     SUB W1, W0, [W15]
001142  34FFFB     BRA LE, .L65
165:                                                                 // permettant de calculer la temprature
166:               }
167:               
168:               void init_Ecomet(){                                                             // Initialise les diffrents composants (PWM, ADC, ...)
001144  07FE6E     RCALL _ADC1_SoftwareTriggerDisable, .LFE48, .LFB49
169:                   
001146  000000     NOP
001148  90001E     MOV [W14+2], W0
00114A  07FE9B     RCALL _ADC1_IsConversionComplete, .LFE51, .LFB52
00114C  A20400     BTG.B W0, #0
00114E  E00400     CP0.B W0
001150  3AFFFB     BRA NZ, .L66
170:                   SYSTEM_Initialize(); 
001152  90001E     MOV [W14+2], W0
001154  07FE6E     RCALL _ADC1_ConversionResultGet, .LFE50, .LFB51
001156  980720     MOV W0, [W14+4]
171:                   
001158  07FE5C     RCALL _ADC1_Disable, .LFE46, .LFB47
172:                   int freq_Buzzer = 0x4E1; // f = 3,2 kHz
00115A  9000AE     MOV [W14+4], W1
00115C  20FFF0     MOV #0xFFF, W0
00115E  780100     MOV W0, W2
001160  090005     REPEAT #0x5
001162  D80082     DIV.SW W1, W2
001164  DE80CF     ASR W0, #15, W1
001166  07F9C3     RCALL ___floatsisf
001168  BE0200     MOV.D W0, W4
00116A  808380     MOV 0x1070, W0
00116C  808391     MOV 0x1072, W1
00116E  BE0100     MOV.D W0, W2
001170  BE0004     MOV.D W4, W0
001172  07FBA2     RCALL ___mulsf3x, ___mulsf3
001174  980730     MOV W0, [W14+6]
001176  980741     MOV W1, [W14+8]
173:                   int DC_Buzzer = 0x00; // DC = 0 %
001178  90007E     MOV [W14+14], W0
00117A  DE80CF     ASR W0, #15, W1
00117C  07F9B8     RCALL ___floatsisf
00117E  90013E     MOV [W14+6], W2
001180  9001CE     MOV [W14+8], W3
001182  07FB9A     RCALL ___mulsf3x, ___mulsf3
001184  BE0400     MOV.D W0, W8
001186  808380     MOV 0x1070, W0
001188  808391     MOV 0x1072, W1
00118A  90013E     MOV [W14+6], W2
00118C  9001CE     MOV [W14+8], W3
00118E  07F9C7     RCALL ___subsf3x, ___subsf3
001190  BE0100     MOV.D W0, W2
001192  BE0008     MOV.D W8, W0
001194  07FAB2     RCALL ___divsf3, ___divsf3x
001196  980750     MOV W0, [W14+10]
001198  980761     MOV W1, [W14+12]
174:                   changeDC_Buzzer(DC_Buzzer);
00119A  200000     MOV #0x0, W0
00119C  23F801     MOV #0x3F80, W1
00119E  8882D0     MOV W0, temp
0011A0  8882E1     MOV W1, 0x105C
175:                   changeFreq_Buzzer(freq_Buzzer);
0011A2  BE044F     MOV.D [--W15], W8
0011A4  FA8000     ULNK
0011A6  060000     RETURN
176:                   
177:                   int freq_Motor = 0xC7; // f = 20 kHz
0011A8  FA0006     LNK #0x6
178:                   DC_Motor = 0x00; // DC = 0 %
179:                   changeFreq_Motor(freq_Motor);
0011AA  070354     RCALL SYSTEM_Initialize
180:                   /* C'est bizrare de faire comme a, mais c'est le seul moyen que 
181:                   //j'ai trouv pour avoir un dead time au dbut 
0011AC  204E10     MOV #0x4E1, W0
0011AE  780F00     MOV W0, [W14]
182:                   et  la fin (et pas juste un seul)*/
0011B0  EB0000     CLR W0
0011B2  980710     MOV W0, [W14+2]
183:                   PWM_DeadTimeHighSet(PWM_GENERATOR_1, 1); // Dead time H : 250 ns 
0011B4  90001E     MOV [W14+2], W0
0011B6  07FEFC     RCALL changeDC_Buzzer
184:                   PWM_DeadTimeLowSet(PWM_GENERATOR_1, 1);
0011B8  78001E     MOV [W14], W0
0011BA  07FF04     RCALL changeFreq_Buzzer
185:                   PWM_DeadTimeLowSet(PWM_GENERATOR_1, 1); // Dead time L : 250 ns 
186:                   PWM_DeadTimeHighSet(PWM_GENERATOR_1, 1);
0011BC  200C70     MOV #0xC7, W0
0011BE  980720     MOV W0, [W14+4]
187:                   PG1STAT = 0b01000;
0011C0  EF3050     CLR DC_Motor
188:               }
0011C2  90002E     MOV [W14+4], W0
0011C4  07FEEB     RCALL changeFreq_Motor
0011C6  200011     MOV #0x1, W1
0011C8  200010     MOV #0x1, W0
0011CA  07FE0E     RCALL _PWM_DeadTimeHighSet, .LFE23, .LFB24
0011CC  200011     MOV #0x1, W1
0011CE  200010     MOV #0x1, W0
0011D0  07FDFA     RCALL _PWM_DeadTimeLowSet, .LFE13, .LFB23
0011D2  200011     MOV #0x1, W1
0011D4  200010     MOV #0x1, W0
0011D6  07FDF7     RCALL _PWM_DeadTimeLowSet, .LFE13, .LFB23
0011D8  200011     MOV #0x1, W1
0011DA  200010     MOV #0x1, W0
0011DC  07FE05     RCALL _PWM_DeadTimeHighSet, .LFE23, .LFB24
0011DE  200080     MOV #0x8, W0
0011E0  881970     MOV W0, PG1STAT
0011E2  FA8000     ULNK
0011E4  060000     RETURN
---  C:/Users/NapAp/Documents/Ecole/M2/Q1/Projet/Software/E_Comet_All_ADC_PWM_OPAMP/Ecomet_All_ADC_PWM_OPAMP.X/./mcc_generated_files/system.h
001836  FA0002     LNK #0x2
001838  780F00     MOV W0, [W14]
00183A  800221     MOV CORCON, W1
00183C  200F20     MOV #0xF2, W0
00183E  608000     AND W1, W0, W0
001840  70001E     IOR W0, [W14], W0
001842  880220     MOV W0, CORCON
001844  FA8000     ULNK
001846  060000     RETURN
---  C:/Users/NapAp/Documents/Ecole/M2/Q1/Projet/Software/E_Comet_All_ADC_PWM_OPAMP/Ecomet_All_ADC_PWM_OPAMP.X/./mcc_generated_files/pwm.h
000D82  FA0004     LNK #0x4
000D84  780F00     MOV W0, [W14]
000D86  980711     MOV W1, [W14+2]
000D88  78001E     MOV [W14], W0
000D8A  500FE1     SUB W0, #0x1, [W15]
000D8C  320003     BRA Z, .L3
000D8E  500FE3     SUB W0, #0x3, [W15]
000D90  320004     BRA Z, .L4
000D94  90009E     MOV [W14+2], W1
000D96  881A91     MOV W1, PG1PER
000D98  370003     BRA .L1
000D9A  90009E     MOV [W14+2], W1
000D9C  881DF1     MOV W1, PG3PER
000D9E  000000     NOP
000D92  370006     BRA .L1
000DA0  FA8000     ULNK
000DA2  060000     RETURN
000DA4  FA0004     LNK #0x4
000DA6  780F00     MOV W0, [W14]
000DA8  980711     MOV W1, [W14+2]
000DAA  78001E     MOV [W14], W0
000DAC  500FE1     SUB W0, #0x1, [W15]
000DAE  320003     BRA Z, .L8
000DB0  500FE3     SUB W0, #0x3, [W15]
000DB2  320004     BRA Z, .L9
000DB6  90009E     MOV [W14+2], W1
000DB8  881A71     MOV W1, PG1DC
000DBA  370003     BRA .L6
000DBC  90009E     MOV [W14+2], W1
000DBE  881DD1     MOV W1, PG3DC
000DC0  000000     NOP
000DB4  370006     BRA .L6
000DC2  FA8000     ULNK
000DC4  060000     RETURN
000DC6  FA0004     LNK #0x4
000DC8  780F00     MOV W0, [W14]
000DCA  980711     MOV W1, [W14+2]
000DCC  78001E     MOV [W14], W0
000DCE  500FE1     SUB W0, #0x1, [W15]
000DD0  320003     BRA Z, .L13
000DD2  500FE3     SUB W0, #0x3, [W15]
000DD4  320004     BRA Z, .L14
000DD8  90009E     MOV [W14+2], W1
000DDA  881AD1     MOV W1, PG1DTL
000DDC  370003     BRA .L11
000DDE  90009E     MOV [W14+2], W1
000DE0  881E31     MOV W1, PG3DTL
000DE2  000000     NOP
000DD6  370006     BRA .L11
000DE4  FA8000     ULNK
000DE6  060000     RETURN
000DE8  FA0004     LNK #0x4
000DEA  780F00     MOV W0, [W14]
000DEC  980711     MOV W1, [W14+2]
000DEE  78001E     MOV [W14], W0
000DF0  500FE1     SUB W0, #0x1, [W15]
000DF2  320003     BRA Z, .L18
000DF4  500FE3     SUB W0, #0x3, [W15]
000DF6  320004     BRA Z, .L19
000DFA  90009E     MOV [W14+2], W1
000DFC  881AE1     MOV W1, PG1DTH
000DFE  370003     BRA .L16
000E00  90009E     MOV [W14+2], W1
000E02  881E41     MOV W1, PG3DTH
000E04  000000     NOP
000DF8  370006     BRA .L16
000E06  FA8000     ULNK
000E08  060000     RETURN
---  C:/Users/NapAp/Documents/Ecole/M2/Q1/Projet/Software/E_Comet_All_ADC_PWM_OPAMP/Ecomet_All_ADC_PWM_OPAMP.X/./mcc_generated_files/opa.h
0018F6  FA0000     LNK #0x0
0018F8  A8E8DD     BSET 0x8DD, #7
0018FA  FA8000     ULNK
0018FC  060000     RETURN
---  C:/Users/NapAp/Documents/Ecole/M2/Q1/Projet/Software/E_Comet_All_ADC_PWM_OPAMP/Ecomet_All_ADC_PWM_OPAMP.X/./mcc_generated_files/interrupt_manager.h
001848  FA0000     LNK #0x0
00184A  A8E8C3     BSET 0x8C3, #7
00184C  000000     NOP
00184E  000000     NOP
001850  FA8000     ULNK
001852  060000     RETURN
---  C:/Users/NapAp/Documents/Ecole/M2/Q1/Projet/Software/E_Comet_All_ADC_PWM_OPAMP/Ecomet_All_ADC_PWM_OPAMP.X/./mcc_generated_files/adc1.h
000E0A  FA0000     LNK #0x0
000E0C  A8EB01     BSET 0xB01, #7
000E0E  FA8000     ULNK
000E10  060000     RETURN
000E12  FA0000     LNK #0x0
000E14  A9EB01     BCLR 0xB01, #7
000E16  FA8000     ULNK
000E18  060000     RETURN
000E1A  FA0000     LNK #0x0
000E1C  A8CB08     BSET ADCON3L, #6
000E1E  FA8000     ULNK
000E20  060000     RETURN
000E22  FA0000     LNK #0x0
000E24  A9CB08     BCLR ADCON3L, #6
000E26  FA8000     ULNK
000E28  060000     RETURN
000E2A  FA0002     LNK #0x2
000E2C  780F00     MOV W0, [W14]
000E2E  FA8000     ULNK
000E30  060000     RETURN
000E32  FA0004     LNK #0x4
000E34  980710     MOV W0, [W14+2]
000E36  90001E     MOV [W14+2], W0
000E38  500FE3     SUB W0, #0x3, [W15]
000E3A  320014     BRA Z, .L30
000E3C  500FE3     SUB W0, #0x3, [W15]
000E3E  3E0005     BRA GTU, .L34
000E40  500FE1     SUB W0, #0x1, [W15]
000E42  32000A     BRA Z, .L28
000E44  500FE2     SUB W0, #0x2, [W15]
000E46  32000B     BRA Z, .L29
000E4A  500FE5     SUB W0, #0x5, [W15]
000E4C  320011     BRA Z, .L32
000E4E  500FE5     SUB W0, #0x5, [W15]
000E50  39000C     BRA NC, .L31
000E52  500FE6     SUB W0, #0x6, [W15]
000E54  320010     BRA Z, .L33
000E58  8060D1     MOV ADCBUF7, W1
000E5A  780F01     MOV W1, [W14]
000E5C  37000F     BRA .L35
000E5E  806121     MOV ADCBUF12, W1
000E60  780F01     MOV W1, [W14]
000E62  37000C     BRA .L35
000E64  806151     MOV ADCBUF15, W1
000E66  780F01     MOV W1, [W14]
000E68  370009     BRA .L35
000E6A  806171     MOV ADCBUF17, W1
000E6C  780F01     MOV W1, [W14]
000E6E  370006     BRA .L35
000E70  806191     MOV ADCBUF19, W1
000E72  780F01     MOV W1, [W14]
000E74  370003     BRA .L35
000E76  8061A1     MOV ADCBUF20, W1
000E78  780F01     MOV W1, [W14]
000E7A  000000     NOP
000E48  370019     BRA .L35
000E56  370012     BRA .L35
000E7C  78001E     MOV [W14], W0
000E7E  FA8000     ULNK
000E80  060000     RETURN
000E82  FA0004     LNK #0x4
000E84  980710     MOV W0, [W14+2]
000E86  90001E     MOV [W14+2], W0
000E88  500FE3     SUB W0, #0x3, [W15]
000E8A  320022     BRA Z, .L40
000E8C  500FE3     SUB W0, #0x3, [W15]
000E8E  3E0005     BRA GTU, .L44
000E90  500FE1     SUB W0, #0x1, [W15]
000E92  32000A     BRA Z, .L38
000E94  500FE2     SUB W0, #0x2, [W15]
000E96  320012     BRA Z, .L39
000E9A  500FE5     SUB W0, #0x5, [W15]
000E9C  32002D     BRA Z, .L42
000E9E  500FE5     SUB W0, #0x5, [W15]
000EA0  390021     BRA NC, .L41
000EA2  500FE6     SUB W0, #0x6, [W15]
000EA4  320033     BRA Z, .L43
000EA8  805980     MOV ADSTATL, W0
000EAA  0A8077     BFEXT #0x7, #0x1, W0, W0
000EAC  000000     NOP
000EAE  FB8000     ZE W0, W0
000EB0  A7F000     BTSC W0, #15
000EB2  EA0000     NEG W0, W0
000EB4  EA0000     NEG W0, W0
000EB6  DE004F     LSR W0, #15, W0
000EB8  784F00     MOV.B W0, [W14]
000EBA  370032     BRA .L45
000EBC  805980     MOV ADSTATL, W0
000EBE  0A80CC     BFEXT #0xc, #0x1, W0, W0
000EC0  000000     NOP
000EC2  FB8000     ZE W0, W0
000EC4  A7F000     BTSC W0, #15
000EC6  EA0000     NEG W0, W0
000EC8  EA0000     NEG W0, W0
000ECA  DE004F     LSR W0, #15, W0
000ECC  784F00     MOV.B W0, [W14]
000ECE  370028     BRA .L45
000ED0  805980     MOV ADSTATL, W0
000ED2  0A80FF     BFEXT #0xf, #0x1, W0, W0
000ED4  000000     NOP
000ED6  FB8000     ZE W0, W0
000ED8  A7F000     BTSC W0, #15
000EDA  EA0000     NEG W0, W0
000EDC  EA0000     NEG W0, W0
000EDE  DE004F     LSR W0, #15, W0
000EE0  784F00     MOV.B W0, [W14]
000EE2  37001E     BRA .L45
000EE4  805990     MOV ADSTATH, W0
000EE6  0A8011     BFEXT #0x1, #0x1, W0, W0
000EE8  000000     NOP
000EEA  FB8000     ZE W0, W0
000EEC  A7F000     BTSC W0, #15
000EEE  EA0000     NEG W0, W0
000EF0  EA0000     NEG W0, W0
000EF2  DE004F     LSR W0, #15, W0
000EF4  784F00     MOV.B W0, [W14]
000EF6  370014     BRA .L45
000EF8  805990     MOV ADSTATH, W0
000EFA  0A8033     BFEXT #0x3, #0x1, W0, W0
000EFC  000000     NOP
000EFE  FB8000     ZE W0, W0
000F00  A7F000     BTSC W0, #15
000F02  EA0000     NEG W0, W0
000F04  EA0000     NEG W0, W0
000F06  DE004F     LSR W0, #15, W0
000F08  784F00     MOV.B W0, [W14]
000F0A  37000A     BRA .L45
000F0C  805990     MOV ADSTATH, W0
000F0E  0A8044     BFEXT #0x4, #0x1, W0, W0
000F10  000000     NOP
000F12  FB8000     ZE W0, W0
000F14  A7F000     BTSC W0, #15
000F16  EA0000     NEG W0, W0
000F18  EA0000     NEG W0, W0
000F1A  DE004F     LSR W0, #15, W0
000F1C  784F00     MOV.B W0, [W14]
000F1E  000000     NOP
000E98  370043     BRA .L45
000EA6  37003C     BRA .L45
000F20  78401E     MOV.B [W14], W0
000F22  FA8000     ULNK
000F24  060000     RETURN
---  /home/xc16/release-builds/build_20230327/src/libmf/src/unpackfx.s  ---------------------------------
000B62  DE0A4F     LSR W1, #15, W4
000B64  DE0947     LSR W1, #7, W2
000B66  B207F1     AND #0x7F, W1
000B68  B20FF2     AND #0xFF, W2
000B6A  32000B     BRA Z, zeroorden
000B6C  B107F2     SUB #0x7F, W2
000B6E  A07001     BSET W1, #7
000B70  DD08C7     SL W1, #7, W1
000B72  DE01C9     LSR W0, #9, W3
000B74  708083     IOR W1, W3, W1
000B76  DD0047     SL W0, #7, W0
000B78  A60004     BTSS W4, #0
000B7A  060000     RETURN
000B7C  100060     SUBR W0, #0x0, W0
000B7E  1880E0     SUBBR W1, #0x0, W1
000B80  060000     RETURN
000B82  700F81     IOR W0, W1, [W15]
000B84  3A0001     BRA NZ, denormal
000B86  060000     RETURN
000B88  CF8281     FF1L W1, W5
000B8A  E00005     CP0 W5
000B8C  3E0010     BRA GTU, skip1
000B8E  CF8280     FF1L W0, W5
000B90  4282EE     ADD W5, #0xE, W5
000B92  E12870     CP W5, #16
000B94  390004     BRA NC, small
000B96  3E0007     BRA GTU, big
000B98  780080     MOV W0, W1
000B9A  EB0000     CLR W0
000B9C  37000E     BRA fin
000B9E  128370     SUBR W5, #0x10, W6
000BA0  DE0086     LSR W0, W6, W1
000BA2  DD0005     SL W0, W5, W0
000BA4  37000A     BRA fin
000BA6  528370     SUB W5, #0x10, W6
000BA8  DD0086     SL W0, W6, W1
000BAA  EB0000     CLR W0
000BAC  370006     BRA fin
000BAE  5282E2     SUB W5, #0x2, W5
000BB0  DD0885     SL W1, W5, W1
000BB2  128370     SUBR W5, #0x10, W6
000BB4  DE0306     LSR W0, W6, W6
000BB6  708086     IOR W1, W6, W1
000BB8  DD0005     SL W0, W5, W0
000BBA  B00775     ADD #0x77, W5
000BBC  EA0105     NEG W5, W2
000BBE  A60004     BTSS W4, #0
000BC0  060000     RETURN
000BC2  100060     SUBR W0, #0x0, W0
000BC4  1880E0     SUBBR W1, #0x0, W1
000BC6  060000     RETURN
---  /home/xc16/release-builds/build_20230327/src/libmf/src/unpackdnrmfx.s  -----------------------------
000A18  BE9F88     MOV.D W8, [W15++]
000A1A  EB0400     CLR W8
000A1C  E13861     CP W7, #1
000A1E  3A0016     BRA NZ, yregs
000A20  E00001     CP0 W1
000A22  3A0008     BRA NZ, x1not0
000A24  DE00C8     LSR W0, #8, W1
000A26  DD0048     SL W0, #8, W0
000A28  200088     MOV #0x8, W8
000A2A  E00001     CP0 W1
000A2C  3A0003     BRA NZ, x1not0
000A2E  DE00C8     LSR W0, #8, W1
000A30  DD0048     SL W0, #8, W0
000A32  440468     ADD W8, #0x8, W8
000A34  CF8481     FF1L W1, W9
000A36  5484E9     SUB W9, #0x9, W9
000A38  340006     BRA LE, x1noshift
000A3A  DD0889     SL W1, W9, W1
000A3C  1483F0     SUBR W9, #0x10, W7
000A3E  DE0387     LSR W0, W7, W7
000A40  708087     IOR W1, W7, W1
000A42  DD0009     SL W0, W9, W0
000A44  440409     ADD W8, W9, W8
000A46  140261     SUBR W8, #0x1, W4
000A48  BE044F     MOV.D [--W15], W8
000A4A  060000     RETURN
000A4C  E00003     CP0 W3
000A4E  3A0008     BRA NZ, y1not0
000A50  DE11C8     LSR W2, #8, W3
000A52  DD1148     SL W2, #8, W2
000A54  200088     MOV #0x8, W8
000A56  E00003     CP0 W3
000A58  3A0003     BRA NZ, y1not0
000A5A  DE11C8     LSR W2, #8, W3
000A5C  DD1148     SL W2, #8, W2
000A5E  440468     ADD W8, #0x8, W8
000A60  CF8483     FF1L W3, W9
000A62  5484E9     SUB W9, #0x9, W9
000A64  340006     BRA LE, y1noshift
000A66  DD1989     SL W3, W9, W3
000A68  1483F0     SUBR W9, #0x10, W7
000A6A  DE1387     LSR W2, W7, W7
000A6C  718187     IOR W3, W7, W3
000A6E  DD1109     SL W2, W9, W2
000A70  440409     ADD W8, W9, W8
000A72  1402E1     SUBR W8, #0x1, W5
000A74  37FFE9     BRA leave
---  /home/xc16/release-builds/build_20230327/src/libmf/src/typefx.s  -----------------------------------
000A76  200027     MOV #0x2, W7
000A78  A7F001     BTSC W1, #15
000A7A  200017     MOV #0x1, W7
000A7C  DE0B47     LSR W1, #7, W6
000A7E  B20FF6     AND #0xFF, W6
000A80  320004     BRA Z, chkzeroordenorm
000A82  E84306     INC.B W6, W6
000A84  32000A     BRA Z, chknanorinf
000A86  B30247     IOR #0x24, W7
000A88  060000     RETURN
000A8A  780301     MOV W1, W6
000A8C  B207F6     AND #0x7F, W6
000A8E  700306     IOR W0, W6, W6
000A90  3A0002     BRA NZ, denormal
000A92  B30307     IOR #0x30, W7
000A94  060000     RETURN
000A96  B30287     IOR #0x28, W7
000A98  060000     RETURN
000A9A  780301     MOV W1, W6
000A9C  B207F6     AND #0x7F, W6
000A9E  700306     IOR W0, W6, W6
000AA0  320002     BRA Z, infinite
000AA2  A07007     BSET W7, #7
000AA4  060000     RETURN
000AA6  A06007     BSET W7, #6
000AA8  060000     RETURN
---  /home/xc16/release-builds/build_20230327/src/libmf/src/spackfx.s  ----------------------------------
000ABC  700181     IOR W0, W1, W3
000ABE  320027     BRA Z, zeroarg
000AC0  EB0280     CLR W5
000AC2  A3F801     BTST.Z W1, #15
000AC4  320003     BRA Z, pos
000AC6  100060     SUBR W0, #0x0, W0
000AC8  1880E0     SUBBR W1, #0x0, W1
000ACA  200015     MOV #0x1, W5
000ACC  2007F4     MOV #0x7F, W4
000ACE  420202     ADD W4, W2, W4
000AD0  340020     BRA LE, denorm
000AD2  2003F7     MOV #0x3F, W7
000AD4  600387     AND W0, W7, W7
000AD6  200406     MOV #0x40, W6
000AD8  630300     AND W6, W0, W6
000ADA  200802     MOV #0x80, W2
000ADC  610100     AND W2, W0, W2
000ADE  DE0047     LSR W0, #7, W0
000AE0  DD09C9     SL W1, #9, W3
000AE2  718000     IOR W3, W0, W0
000AE4  DE08C7     LSR W1, #7, W1
000AE6  E00006     CP0 W6
000AE8  320008     BRA Z, fin
000AEA  710387     IOR W2, W7, W7
000AEC  320006     BRA Z, fin
000AEE  B00010     ADD #0x1, W0
000AF0  B08001     ADDC #0x0, W1
000AF2  A38801     BTST.Z W1, #8
000AF4  320002     BRA Z, fin
000AF6  DE08C1     LSR W1, #1, W1
000AF8  E80204     INC W4, W4
000AFA  B207F1     AND #0x7F, W1
000AFC  200FF3     MOV #0xFF, W3
000AFE  E12003     CP W4, W3
000B00  3D0003     BRA GE, infinite
000B02  DD2247     SL W4, #7, W4
000B04  720081     IOR W4, W1, W1
000B06  370029     BRA signfix
000B08  27F801     MOV #0x7F80, W1
000B0A  EB0000     CLR W0
000B0C  370026     BRA signfix
000B0E  B80060     MUL.UU W0, #0x0, W0
000B10  060000     RETURN
000B12  120268     SUBR W4, #0x8, W4
000B14  E1207F     CP W4, #31
000B16  340002     BRA LE, l2
000B18  B80060     MUL.UU W0, #0x0, W0
000B1A  37001F     BRA signfix
000B1C  B81160     MUL.UU W2, #0x0, W2
000B1E  E12070     CP W4, #16
000B20  350004     BRA LT, l3
000B22  780180     MOV W0, W3
000B24  780001     MOV W1, W0
000B26  EB0080     CLR W1
000B28  520270     SUB W4, #0x10, W4
000B2A  E00004     CP0 W4
000B2C  340009     BRA LE, l4
000B2E  1203F0     SUBR W4, #0x10, W7
000B30  DD1907     SL W3, W7, W2
000B32  DE1984     LSR W3, W4, W3
000B34  DD0307     SL W0, W7, W6
000B36  718186     IOR W3, W6, W3
000B38  DE0004     LSR W0, W4, W0
000B3A  DD0B07     SL W1, W7, W6
000B3C  700006     IOR W0, W6, W0
000B3E  DE0884     LSR W1, W4, W1
000B40  27FFF7     MOV #0x7FFF, W7
000B42  638383     AND W7, W3, W7
000B44  710387     IOR W2, W7, W7
000B46  280006     MOV #0x8000, W6
000B48  630303     AND W6, W3, W6
000B4A  320007     BRA Z, signfix
000B4C  E00007     CP0 W7
000B4E  3A0003     BRA NZ, l5
000B50  600161     AND W0, #0x1, W2
000B52  738102     IOR W7, W2, W2
000B54  320002     BRA Z, signfix
000B56  B00010     ADD #0x1, W0
000B58  B08001     ADDC #0x0, W1
000B5A  A60005     BTSS W5, #0
000B5C  060000     RETURN
000B5E  A0F001     BSET W1, #15
000B60  060000     RETURN
---  /home/xc16/release-builds/build_20230327/src/libmf/src/propnanfx.s  --------------------------------
000AAA  A37804     BTST.Z W4, #7
000AAC  320004     BRA Z, returny
000AAE  A37805     BTST.Z W5, #7
000AB0  320003     BRA Z, leave
000AB2  A36801     BTST.Z W1, #6
000AB4  3A0001     BRA NZ, leave
000AB6  BE0002     MOV.D W2, W0
000AB8  A06001     BSET W1, #6
000ABA  060000     RETURN
---  /home/xc16/release-builds/build_20230327/src/libmf/src/mulsf3x.s  ----------------------------------
0008B8  688303     XOR W1, W3, W6
0008BA  280007     MOV #0x8000, W7
0008BC  630307     AND W6, W7, W6
0008BE  DE0A47     LSR W1, #7, W4
0008C0  A18004     BCLR W4, #8
0008C2  DE1AC7     LSR W3, #7, W5
0008C4  A18005     BCLR W5, #8
0008C6  200FF7     MOV #0xFF, W7
0008C8  E12007     CP W4, W7
0008CA  320042     BRA Z, bigarg
0008CC  E12807     CP W5, W7
0008CE  320040     BRA Z, bigarg
0008D0  BE9F88     MOV.D W8, [W15++]
0008D2  BE9F8A     MOV.D W10, [W15++]
0008D4  781F8C     MOV W12, [W15++]
0008D6  B207F1     AND #0x7F, W1
0008D8  B207F3     AND #0x7F, W3
0008DA  E00004     CP0 W4
0008DC  320064     BRA Z, smallx
0008DE  A07001     BSET W1, #7
0008E0  E00005     CP0 W5
0008E2  320068     BRA Z, smally
0008E4  A07003     BSET W3, #7
0008E6  420585     ADD W4, W5, W11
0008E8  B107EB     SUB #0x7E, W11
0008EA  B80402     MUL.UU W0, W2, W8
0008EC  B80203     MUL.UU W0, W3, W4
0008EE  448484     ADD W9, W4, W9
0008F0  4A8560     ADDC W5, #0x0, W10
0008F2  B80A02     MUL.UU W1, W2, W4
0008F4  448484     ADD W9, W4, W9
0008F6  4A850A     ADDC W5, W10, W10
0008F8  B80A03     MUL.UU W1, W3, W4
0008FA  450504     ADD W10, W4, W10
0008FC  330004     BRA N, noadjust
0008FE  D00408     SL W8, W8
000900  D28489     RLC W9, W9
000902  D2850A     RLC W10, W10
000904  E9058B     DEC W11, W11
000906  E15861     CP W11, #1
000908  35003D     BRA LT, isdenorm
00090A  201002     MOV #0x100, W2
00090C  610109     AND W2, W9, W2
00090E  200803     MOV #0x80, W3
000910  618189     AND W3, W9, W3
000912  2007F7     MOV #0x7F, W7
000914  648387     AND W9, W7, W7
000916  738608     IOR W7, W8, W12
000918  DE4CC8     LSR W9, #8, W9
00091A  DD53C8     SL W10, #8, W7
00091C  748487     IOR W9, W7, W9
00091E  DE5548     LSR W10, #8, W10
000920  E00003     CP0 W3
000922  320006     BRA Z, noaddlsb
000924  760382     IOR W12, W2, W7
000926  320004     BRA Z, noaddlsb
000928  E80489     INC W9, W9
00092A  4D0560     ADDC W10, #0x0, W10
00092C  A3880A     BTST.Z W10, #8
00092E  3A000C     BRA NZ, carrytob8
000930  200FF7     MOV #0xFF, W7
000932  E15807     CP W11, W7
000934  3D0044     BRA GE, overflow
000936  A1700A     BCLR W10, #7
000938  DD5DC7     SL W11, #7, W11
00093A  75850A     IOR W11, W10, W10
00093C  73008A     IOR W6, W10, W1
00093E  780009     MOV W9, W0
000940  78064F     MOV [--W15], W12
000942  BE054F     MOV.D [--W15], W10
000944  BE044F     MOV.D [--W15], W8
000946  060000     RETURN
000948  D1050A     LSR W10, W10
00094A  D38489     RRC W9, W9
00094C  E8058B     INC W11, W11
00094E  37FFF0     BRA noaddlsb
000950  781F88     MOV W8, [W15++]
000952  780406     MOV W6, W8
000954  070090     RCALL __typef
000956  780207     MOV W7, W4
000958  FD0100     EXCH W0, W2
00095A  FD0181     EXCH W1, W3
00095C  07008C     RCALL __typef
00095E  780287     MOV W7, W5
000960  720385     IOR W4, W5, W7
000962  A37807     BTST.Z W7, #7
000964  320005     BRA Z, checkfor0
000966  FD0100     EXCH W0, W2
000968  FD0181     EXCH W1, W3
00096A  07009F     RCALL __propnanf
00096C  78044F     MOV [--W15], W8
00096E  060000     RETURN
000970  720385     IOR W4, W5, W7
000972  A34807     BTST.Z W7, #4
000974  320003     BRA Z, retinf
000976  2FFFF0     MOV #0xFFFF, W0
000978  27FFF1     MOV #0x7FFF, W1
00097A  37FFF8     BRA leavebigarg
00097C  200000     MOV #0x0, W0
00097E  27F801     MOV #0x7F80, W1
000980  708088     IOR W1, W8, W1
000982  37FFF4     BRA leavebigarg
000984  780188     MOV W8, W3
000986  DD4848     SL W9, #8, W0
000988  718180     IOR W3, W0, W3
00098A  DE4848     LSR W9, #8, W0
00098C  DD50C8     SL W10, #8, W1
00098E  700001     IOR W0, W1, W0
000990  DE50C8     LSR W10, #8, W1
000992  780406     MOV W6, W8
000994  78010B     MOV W11, W2
000996  070016     RCALL __dnrmpackf
000998  708088     IOR W1, W8, W1
00099A  37FFD2     BRA leave
00099C  E00005     CP0 W5
00099E  320005     BRA Z, retsignedzero
0009A0  200017     MOV #0x1, W7
0009A2  07003A     RCALL __unpackdnrmf
0009A4  37FF9D     BRA xback
0009A6  700381     IOR W0, W1, W7
0009A8  3AFFF9     BRA NZ, smallxchky
0009AA  780086     MOV W6, W1
0009AC  78064F     MOV [--W15], W12
0009AE  BE054F     MOV.D [--W15], W10
0009B0  BE044F     MOV.D [--W15], W8
0009B2  050000     RETLW #0x0, W0
0009B4  710383     IOR W2, W3, W7
0009B6  32FFF9     BRA Z, retsignedzero
0009B8  200027     MOV #0x2, W7
0009BA  07002E     RCALL __unpackdnrmf
0009BC  37FF94     BRA yback
0009BE  27F801     MOV #0x7F80, W1
0009C0  708086     IOR W1, W6, W1
0009C2  37FFF4     BRA leaveres0set0
---  /home/xc16/release-builds/build_20230327/src/libmf/src/dnrmpackfx.s  -------------------------------
0009C4  E00001     CP0 W1
0009C6  320026     BRA Z, ret0
0009C8  110161     SUBR W2, #0x1, W2
0009CA  E11078     CP W2, #24
0009CC  3C0023     BRA GT, ret0
0009CE  B82260     MUL.UU W4, #0x0, W4
0009D0  E11070     CP W2, #16
0009D2  350004     BRA LT, sclt16
0009D4  780280     MOV W0, W5
0009D6  780001     MOV W1, W0
0009D8  EB0080     CLR W1
0009DA  510170     SUB W2, #0x10, W2
0009DC  E00002     CP0 W2
0009DE  340009     BRA LE, L1
0009E0  110370     SUBR W2, #0x10, W6
0009E2  DD2A06     SL W5, W6, W4
0009E4  DE2A82     LSR W5, W2, W5
0009E6  DD0386     SL W0, W6, W7
0009E8  728287     IOR W5, W7, W5
0009EA  DE0002     LSR W0, W2, W0
0009EC  DD0B86     SL W1, W6, W7
0009EE  700007     IOR W0, W7, W0
0009F0  DE0882     LSR W1, W2, W1
0009F2  718184     IOR W3, W4, W3
0009F4  27FFF4     MOV #0x7FFF, W4
0009F6  628204     AND W5, W4, W4
0009F8  718184     IOR W3, W4, W3
0009FA  280004     MOV #0x8000, W4
0009FC  628284     AND W5, W4, W5
0009FE  600261     AND W0, #0x1, W4
000A00  A6F005     BTSS W5, #15
000A02  060000     RETURN
000A04  718204     IOR W3, W4, W4
000A06  320007     BRA Z, leave
000A08  E80000     INC W0, W0
000A0A  4880E0     ADDC W1, #0x0, W1
000A0C  060000     RETURN
000A0E  BE0200     MOV.D W0, W4
000A10  B80060     MUL.UU W0, #0x0, W0
000A12  37FFEF     BRA L1
000A14  B80060     MUL.UU W0, #0x0, W0
000A16  060000     RETURN
---  /home/xc16/release-builds/build_20230327/src/libmf/src/divsf3x.s  ----------------------------------
0006FA  BE9F88     MOV.D W8, [W15++]
0006FC  BE9F8A     MOV.D W10, [W15++]
0006FE  BE9F8C     MOV.D W12, [W15++]
000700  20001B     MOV #0x1, W11
000702  BE0202     MOV.D W2, W4
000704  688605     XOR W1, W5, W12
000706  280006     MOV #0x8000, W6
000708  660606     AND W12, W6, W12
00070A  DE0947     LSR W1, #7, W2
00070C  B20FF2     AND #0xFF, W2
00070E  320082     BRA Z, chkarg
000710  E84302     INC.B W2, W6
000712  320080     BRA Z, chkarg
000714  DE29C7     LSR W5, #7, W3
000716  B20FF3     AND #0xFF, W3
000718  32007D     BRA Z, chkarg
00071A  E84303     INC.B W3, W6
00071C  32007B     BRA Z, chkarg
00071E  B207F1     AND #0x7F, W1
000720  A07001     BSET W1, #7
000722  B207F5     AND #0x7F, W5
000724  A07005     BSET W5, #7
000726  DD08C7     SL W1, #7, W1
000728  DE0349     LSR W0, #9, W6
00072A  708086     IOR W1, W6, W1
00072C  DD0047     SL W0, #7, W0
00072E  DD2AC7     SL W5, #7, W5
000730  DE2349     LSR W4, #9, W6
000732  728286     IOR W5, W6, W5
000734  DD2247     SL W4, #7, W4
000736  510503     SUB W2, W3, W10
000738  500304     SUB W0, W4, W6
00073A  588385     SUBB W1, W5, W7
00073C  310003     BRA C, l2
00073E  400000     ADD W0, W0, W0
000740  488081     ADDC W1, W1, W1
000742  E9050A     DEC W10, W10
000744  781F8C     MOV W12, [W15++]
000746  BE9F8A     MOV.D W10, [W15++]
000748  500004     SUB W0, W4, W0
00074A  588085     SUBB W1, W5, W1
00074C  420204     ADD W4, W4, W4
00074E  4A8285     ADDC W5, W5, W5
000750  400000     ADD W0, W0, W0
000752  488081     ADDC W1, W1, W1
000754  EB0500     CLR W10
000756  BE0400     MOV.D W0, W8
000758  B83360     MUL.UU W6, #0x0, W6
00075A  BE0604     MOV.D W4, W12
00075C  E1480D     CP W9, W13
00075E  310056     BRA C, l4
000760  090005     REPEAT #0x5
000762  D8CC4D     DIV.UD W8, W13
000764  B8010C     MUL.UU W0, W12, W2
000766  B8020D     MUL.UU W0, W13, W4
000768  418184     ADD W3, W4, W3
00076A  4A8260     ADDC W5, #0x0, W4
00076C  538382     SUB W7, W2, W7
00076E  5C0403     SUBB W8, W3, W8
000770  5C8484     SUBB W9, W4, W9
000772  5D0560     SUBB W10, #0x0, W10
000774  E0000A     CP0 W10
000776  3A0025     BRA NZ, l10a
000778  780580     MOV W0, W11
00077A  E1400D     CP W8, W13
00077C  310049     BRA C, l7
00077E  780088     MOV W8, W1
000780  780007     MOV W7, W0
000782  090005     REPEAT #0x5
000784  D8884D     DIV.UD W0, W13
000786  B8010C     MUL.UU W0, W12, W2
000788  B8020D     MUL.UU W0, W13, W4
00078A  418184     ADD W3, W4, W3
00078C  4A8260     ADDC W5, #0x0, W4
00078E  110360     SUBR W2, #0x0, W6
000790  5B8383     SUBB W7, W3, W7
000792  5C0404     SUBB W8, W4, W8
000794  5C84E0     SUBB W9, #0x0, W9
000796  E00009     CP0 W9
000798  3A0021     BRA NZ, l10b
00079A  BE014F     MOV.D [--W15], W2
00079C  E00003     CP0 W3
00079E  32002B     BRA Z, l11
0007A0  6001E3     AND W0, #0x3, W3
0007A2  730607     IOR W6, W7, W12
0007A4  71818C     IOR W3, W12, W3
0007A6  320001     BRA Z, l10
0007A8  700064     IOR W0, #0x4, W0
0007AA  DE0042     LSR W0, #2, W0
0007AC  DD5E4E     SL W11, #14, W12
0007AE  70000C     IOR W0, W12, W0
0007B0  DE58C2     LSR W11, #2, W1
0007B2  A0E001     BSET W1, #14
0007B4  070183     RCALL __spackf
0007B6  7801CF     MOV [--W15], W3
0007B8  718081     IOR W3, W1, W1
0007BA  BE064F     MOV.D [--W15], W12
0007BC  BE054F     MOV.D [--W15], W10
0007BE  BE044F     MOV.D [--W15], W8
0007C0  060000     RETURN
0007C2  43838C     ADD W7, W12, W7
0007C4  4C040D     ADDC W8, W13, W8
0007C6  4C84E0     ADDC W9, #0x0, W9
0007C8  4D0560     ADDC W10, #0x0, W10
0007CA  E90000     DEC W0, W0
0007CC  E0000A     CP0 W10
0007CE  32FFD4     BRA Z, l6
0007D0  43838C     ADD W7, W12, W7
0007D2  4C040D     ADDC W8, W13, W8
0007D4  4C84E0     ADDC W9, #0x0, W9
0007D6  4D0560     ADDC W10, #0x0, W10
0007D8  E90000     DEC W0, W0
0007DA  37FFCE     BRA l6
0007DC  43030C     ADD W6, W12, W6
0007DE  4B838D     ADDC W7, W13, W7
0007E0  4C0460     ADDC W8, #0x0, W8
0007E2  4C84E0     ADDC W9, #0x0, W9
0007E4  E90000     DEC W0, W0
0007E6  E00009     CP0 W9
0007E8  32FFD8     BRA Z, l9
0007EA  43030C     ADD W6, W12, W6
0007EC  4B838D     ADDC W7, W13, W7
0007EE  4C0460     ADDC W8, #0x0, W8
0007F0  4C84E0     ADDC W9, #0x0, W9
0007F2  E90000     DEC W0, W0
0007F4  37FFD2     BRA l9
0007F6  DE0042     LSR W0, #2, W0
0007F8  DD5E4E     SL W11, #14, W12
0007FA  70000C     IOR W0, W12, W0
0007FC  DE58C2     LSR W11, #2, W1
0007FE  A0E001     BSET W1, #14
000800  7801CF     MOV [--W15], W3
000802  E00003     CP0 W3
000804  32FFDA     BRA Z, final
000806  100060     SUBR W0, #0x0, W0
000808  1880E0     SUBBR W1, #0x0, W1
00080A  37FFD7     BRA final
00080C  2FFFF0     MOV #0xFFFF, W0
00080E  37FFAA     BRA l5
000810  2FFFF0     MOV #0xFFFF, W0
000812  37FFB9     BRA l8
000814  BE0404     MOV.D W4, W8
000816  07012F     RCALL __typef
000818  780687     MOV W7, W13
00081A  FD0400     EXCH W0, W8
00081C  FD0481     EXCH W1, W9
00081E  07012B     RCALL __typef
000820  668307     AND W13, W7, W6
000822  A37806     BTST.Z W6, #7
000824  320003     BRA Z, l12
000826  A76009     BTSC W9, #6
000828  BE0008     MOV.D W8, W0
00082A  37002C     BRA setedom
00082C  A3780D     BTST.Z W13, #7
00082E  320002     BRA Z, l13
000830  BE0008     MOV.D W8, W0
000832  370028     BRA setedom
000834  A37807     BTST.Z W7, #7
000836  3A0026     BRA NZ, setedom
000838  A1F001     BCLR W1, #15
00083A  A1F009     BCLR W9, #15
00083C  A36806     BTST.Z W6, #6
00083E  320003     BRA Z, l14
000840  27FFF1     MOV #0x7FFF, W1
000842  2FFFF0     MOV #0xFFFF, W0
000844  37FFBA     BRA final
000846  A3680D     BTST.Z W13, #6
000848  320003     BRA Z, l15
00084A  BE0008     MOV.D W8, W0
00084C  70808C     IOR W1, W12, W1
00084E  37FFB5     BRA final
000850  A36807     BTST.Z W7, #6
000852  3A0007     BRA NZ, retzero
000854  A34806     BTST.Z W6, #4
000856  320003     BRA Z, l16
000858  27FFF1     MOV #0x7FFF, W1
00085A  2FFFF0     MOV #0xFFFF, W0
00085C  37FFAE     BRA final
00085E  A3480D     BTST.Z W13, #4
000860  320003     BRA Z, l17
000862  B80060     MUL.UU W0, #0x0, W0
000864  70808C     IOR W1, W12, W1
000866  37FFA9     BRA final
000868  A34807     BTST.Z W7, #4
00086A  320004     BRA Z, l18
00086C  27F801     MOV #0x7F80, W1
00086E  200000     MOV #0x0, W0
000870  70808C     IOR W1, W12, W1
000872  37FFA3     BRA final
000874  070176     RCALL __unpackf
000876  FD0400     EXCH W0, W8
000878  FD0481     EXCH W1, W9
00087A  780502     MOV W2, W10
00087C  070172     RCALL __unpackf
00087E  BE0208     MOV.D W8, W4
000880  78018A     MOV W10, W3
000882  37FF59     BRA divfsub
000884  A06001     BSET W1, #6
000886  200212     MOV #0x21, W2
000888  8883B2     MOV W2, _errno
00088A  37FF97     BRA final
00088C  E00001     CP0 W1
00088E  320012     BRA Z, zero_res
000890  E00005     CP0 W5
000892  320010     BRA Z, zero_res
000894  BE9F88     MOV.D W8, [W15++]
000896  BE9F8A     MOV.D W10, [W15++]
000898  BE9F8C     MOV.D W12, [W15++]
00089A  EB0600     CLR W12
00089C  A3F801     BTST.Z W1, #15
00089E  320003     BRA Z, testb
0008A0  100060     SUBR W0, #0x0, W0
0008A2  1880E0     SUBBR W1, #0x0, W1
0008A4  A0F00C     BSET W12, #15
0008A6  A3F805     BTST.Z W5, #15
0008A8  320003     BRA Z, l1
0008AA  120260     SUBR W4, #0x0, W4
0008AC  1A82E0     SUBBR W5, #0x0, W5
0008AE  A2F00C     BTG W12, #15
0008B0  EB0580     CLR W11
0008B2  37FF41     BRA divfsub
0008B4  B80060     MUL.UU W0, #0x0, W0
0008B6  050002     RETLW #0x0, W2
---  /home/xc16/release-builds/build_20230327/src/libmf/src/addsf3x.s  ----------------------------------
00051E  27F807     MOV #0x7F80, W7
000520  618307     AND W3, W7, W6
000522  E13806     CP W7, W6
000524  3A0004     BRA NZ, subtoggle
000526  2007F7     MOV #0x7F, W7
000528  618387     AND W3, W7, W7
00052A  710387     IOR W2, W7, W7
00052C  3A0001     BRA NZ, ___addsf3x, ___addsf3
00052E  A2F003     BTG W3, #15
000530  BE9F88     MOV.D W8, [W15++]
000532  BE9F8A     MOV.D W10, [W15++]
000534  BE9F8C     MOV.D W12, [W15++]
000536  DE0A47     LSR W1, #7, W4
000538  A18004     BCLR W4, #8
00053A  DE1AC7     LSR W3, #7, W5
00053C  A18005     BCLR W5, #8
00053E  280007     MOV #0x8000, W7
000540  608507     AND W1, W7, W10
000542  618587     AND W3, W7, W11
000544  200FF7     MOV #0xFF, W7
000546  E12007     CP W4, W7
000548  32009E     BRA Z, bigarg
00054A  E12807     CP W5, W7
00054C  32009C     BRA Z, bigarg
00054E  780601     MOV W1, W12
000550  E00004     CP0 W4
000552  3200B4     BRA Z, smallx
000554  2007F7     MOV #0x7F, W7
000556  608087     AND W1, W7, W1
000558  A07001     BSET W1, #7
00055A  E00005     CP0 W5
00055C  3200C0     BRA Z, smally
00055E  2007F7     MOV #0x7F, W7
000560  618187     AND W3, W7, W3
000562  A07003     BSET W3, #7
000564  520605     SUB W4, W5, W12
000566  3A000F     BRA NZ, xexpyexpnoteq
000568  E1500B     CP W10, W11
00056A  32000B     BRA Z, signeq
00056C  E10803     CP W1, W3
00056E  3A0002     BRA NZ, x1y1noteq
000570  E10002     CP W0, W2
000572  32007E     BRA Z, return0
000574  500402     SUB W0, W2, W8
000576  588483     SUBB W1, W3, W9
000578  310004     BRA C, signeq
00057A  FD0100     EXCH W0, W2
00057C  FD0181     EXCH W1, W3
00057E  FD0284     EXCH W4, W5
000580  FD058A     EXCH W10, W11
000582  B84460     MUL.UU W8, #0x0, W8
000584  370021     BRA bottomexp
000586  E12005     CP W4, W5
000588  3D0005     BRA GE, xexpgeyexp
00058A  FD0100     EXCH W0, W2
00058C  FD0181     EXCH W1, W3
00058E  FD0284     EXCH W4, W5
000590  FD058A     EXCH W10, W11
000592  520605     SUB W4, W5, W12
000594  E1607A     CP W12, #26
000596  350005     BRA LT, sclt26
000598  A17001     BCLR W1, #7
00059A  DD2247     SL W4, #7, W4
00059C  708084     IOR W1, W4, W1
00059E  70808A     IOR W1, W10, W1
0005A0  370063     BRA leave
0005A2  B84460     MUL.UU W8, #0x0, W8
0005A4  6602EF     AND W12, #0xF, W5
0005A6  2FFF07     MOV #0xFFF0, W7
0005A8  660607     AND W12, W7, W12
0005AA  E00005     CP0 W5
0005AC  340006     BRA LE, scnoshift
0005AE  1283F0     SUBR W5, #0x10, W7
0005B0  DD1487     SL W2, W7, W9
0005B2  DE1105     LSR W2, W5, W2
0005B4  DD1B07     SL W3, W7, W6
0005B6  710106     IOR W2, W6, W2
0005B8  DE1985     LSR W3, W5, W3
0005BA  E16070     CP W12, #16
0005BC  350005     BRA LT, bottomexp
0005BE  780409     MOV W9, W8
0005C0  780482     MOV W2, W9
0005C2  780103     MOV W3, W2
0005C4  EB0180     CLR W3
0005C6  560670     SUB W12, #0x10, W12
0005C8  E1500B     CP W10, W11
0005CA  3A0003     BRA NZ, dosubt
0005CC  400002     ADD W0, W2, W0
0005CE  488083     ADDC W1, W3, W1
0005D0  370004     BRA createres
0005D2  140460     SUBR W8, #0x0, W8
0005D4  1C84E0     SUBBR W9, #0x0, W9
0005D6  580002     SUBB W0, W2, W0
0005D8  588083     SUBB W1, W3, W1
0005DA  A38801     BTST.Z W1, #8
0005DC  320006     BRA Z, nocarry
0005DE  D10081     LSR W1, W1
0005E0  D38000     RRC W0, W0
0005E2  D38489     RRC W9, W9
0005E4  D38408     RRC W8, W8
0005E6  E80204     INC W4, W4
0005E8  370027     BRA nonorm
0005EA  A37801     BTST.Z W1, #7
0005EC  3A0025     BRA NZ, nonorm
0005EE  E00001     CP0 W1
0005F0  320003     BRA Z, l2
0005F2  CF8681     FF1L W1, W13
0005F4  568669     SUB W13, #0x9, W12
0005F6  37000A     BRA l3
0005F8  20008C     MOV #0x8, W12
0005FA  E00000     CP0 W0
0005FC  3A0004     BRA NZ, l2not0
0005FE  780009     MOV W9, W0
000600  780488     MOV W8, W9
000602  EB0400     CLR W8
000604  520270     SUB W4, #0x10, W4
000606  CF8680     FF1L W0, W13
000608  46060D     ADD W12, W13, W12
00060A  E9060C     DEC W12, W12
00060C  E16070     CP W12, #16
00060E  350006     BRA LT, l4sclt16
000610  780080     MOV W0, W1
000612  780009     MOV W9, W0
000614  780488     MOV W8, W9
000616  EB0400     CLR W8
000618  560670     SUB W12, #0x10, W12
00061A  520270     SUB W4, #0x10, W4
00061C  E0000C     CP0 W12
00061E  34000C     BRA LE, nonorm
000620  DD088C     SL W1, W12, W1
000622  1603F0     SUBR W12, #0x10, W7
000624  DE0307     LSR W0, W7, W6
000626  708086     IOR W1, W6, W1
000628  DD000C     SL W0, W12, W0
00062A  DE4B07     LSR W9, W7, W6
00062C  700006     IOR W0, W6, W0
00062E  DD4C8C     SL W9, W12, W9
000630  DE4307     LSR W8, W7, W6
000632  748486     IOR W9, W6, W9
000634  DD440C     SL W8, W12, W8
000636  52020C     SUB W4, W12, W4
000638  E12061     CP W4, #1
00063A  350020     BRA LT, resdenorm
00063C  600161     AND W0, #0x1, W2
00063E  280007     MOV #0x8000, W7
000640  648187     AND W9, W7, W3
000642  27FFF7     MOV #0x7FFF, W7
000644  648387     AND W9, W7, W7
000646  740307     IOR W8, W7, W6
000648  E00003     CP0 W3
00064A  320006     BRA Z, noaddlsb
00064C  730382     IOR W6, W2, W7
00064E  320004     BRA Z, noaddlsb
000650  E80000     INC W0, W0
000652  4880E0     ADDC W1, #0x0, W1
000654  A38801     BTST.Z W1, #8
000656  3A000E     BRA NZ, carryb8
000658  200FF7     MOV #0xFF, W7
00065A  E12007     CP W4, W7
00065C  3D004A     BRA GE, overflow
00065E  A17001     BCLR W1, #7
000660  DD2247     SL W4, #7, W4
000662  720081     IOR W4, W1, W1
000664  70808A     IOR W1, W10, W1
000666  BE0000     MOV.D W0, W0
000668  BE064F     MOV.D [--W15], W12
00066A  BE054F     MOV.D [--W15], W10
00066C  BE044F     MOV.D [--W15], W8
00066E  060000     RETURN
000670  B80060     MUL.UU W0, #0x0, W0
000672  37FFFA     BRA leave
000674  D10081     LSR W1, W1
000676  D38000     RRC W0, W0
000678  E80204     INC W4, W4
00067A  37FFEE     BRA noaddlsb
00067C  780104     MOV W4, W2
00067E  740189     IOR W8, W9, W3
000680  0701A1     RCALL __dnrmpackf
000682  70808A     IOR W1, W10, W1
000684  37FFF1     BRA leave
000686  0701F7     RCALL __typef
000688  780207     MOV W7, W4
00068A  FD0100     EXCH W0, W2
00068C  FD0181     EXCH W1, W3
00068E  0701F3     RCALL __typef
000690  780287     MOV W7, W5
000692  720385     IOR W4, W5, W7
000694  A37807     BTST.Z W7, #7
000696  320004     BRA Z, checkforinf
000698  FD0100     EXCH W0, W2
00069A  FD0181     EXCH W1, W3
00069C  070206     RCALL __propnanf
00069E  37FFE4     BRA leave
0006A0  620385     AND W4, W5, W7
0006A2  A36807     BTST.Z W7, #6
0006A4  320008     BRA Z, chkxinf
0006A6  E1500B     CP W10, W11
0006A8  320003     BRA Z, retx
0006AA  2FFFF0     MOV #0xFFFF, W0
0006AC  27FFF1     MOV #0x7FFF, W1
0006AE  37FFDC     BRA leave
0006B0  FD0100     EXCH W0, W2
0006B2  FD0181     EXCH W1, W3
0006B4  37FFD9     BRA leave
0006B6  A36804     BTST.Z W4, #6
0006B8  32FFD7     BRA Z, leave
0006BA  37FFFA     BRA retx
0006BC  27FFF8     MOV #0x7FFF, W8
0006BE  608388     AND W1, W8, W7
0006C0  3A000B     BRA NZ, smallxdenorm
0006C2  E00000     CP0 W0
0006C4  3A0009     BRA NZ, smallxdenorm
0006C6  640383     AND W8, W3, W7
0006C8  738382     IOR W7, W2, W7
0006CA  320002     BRA Z, xandy0
0006CC  BE0002     MOV.D W2, W0
0006CE  37FFCC     BRA leave
0006D0  E1500B     CP W10, W11
0006D2  3AFFCE     BRA NZ, return0
0006D4  BE0002     MOV.D W2, W0
0006D6  37FFC8     BRA leave
0006D8  200014     MOV #0x1, W4
0006DA  640081     AND W8, W1, W1
0006DC  37FF3E     BRA xback
0006DE  27FFF8     MOV #0x7FFF, W8
0006E0  618388     AND W3, W8, W7
0006E2  3A0004     BRA NZ, smallydenorm
0006E4  E00002     CP0 W2
0006E6  3A0002     BRA NZ, smallydenorm
0006E8  78008C     MOV W12, W1
0006EA  37FFBE     BRA leave
0006EC  200015     MOV #0x1, W5
0006EE  640183     AND W8, W3, W3
0006F0  37FF39     BRA yback
0006F2  27F801     MOV #0x7F80, W1
0006F4  200000     MOV #0x0, W0
0006F6  750081     IOR W10, W1, W1
0006F8  37FFB7     BRA leave
---  /home/xc16/release-builds/build_20230327/src/libm/src/funpack2.s  ----------------------------------
000D72  BE0400     MOV.D W0, W8
000D74  07FBBF     RCALL __funpack
000D76  BE0300     MOV.D W0, W6
000D78  BE0504     MOV.D W4, W10
000D7A  BE0002     MOV.D W2, W0
000D7C  07FBBB     RCALL __funpack
000D7E  754F84     IOR.B W10, W4, [W15]
000D80  060000     RETURN
---  /home/xc16/release-builds/build_20230327/src/libm/src/funpack.s  -----------------------------------
0004F4  DE0AC7     LSR W1, #7, W5
0004F6  B207F1     AND #0x7F, W1
0004F8  B20FF5     AND #0xFF, W5
0004FA  320008     BRA Z, zeroorsub
0004FC  42CFE1     ADD.B W5, #0x1, [W15]
0004FE  320002     BRA Z, nanorinf
000500  A07001     BSET W1, #7
000502  050024     RETLW #0x2, W4
000504  700F81     IOR W0, W1, [W15]
000506  320001     BRA Z, infinite
000508  050804     RETLW #0x80, W4
00050A  050044     RETLW #0x4, W4
00050C  700F81     IOR W0, W1, [W15]
00050E  3A0002     BRA NZ, subnormal
000510  050014     RETLW #0x1, W4
000512  E90285     DEC W5, W5
000514  400000     ADD W0, W0, W0
000516  48C081     ADDC.B W1, W1, W1
000518  3BFFFC     BRA NN, normalize
00051A  A07001     BSET W1, #7
00051C  050024     RETLW #0x2, W4
---  /home/xc16/release-builds/build_20230327/src/libm/src/fpack.s  -------------------------------------
000C46  200081     MOV #0x8, W1
000C48  558061     SUB W11, #0x1, W0
000C4A  3D000B     BRA GE, notsubnormal
000C4C  20000B     MOV #0x0, W11
000C4E  2FFE61     MOV #0xFFE6, W1
000C50  E10001     CP W0, W1
000C52  34001D     BRA LE, zerosig
000C54  718182     IOR W3, W2, W3
000C56  640161     AND W8, #0x1, W2
000C58  D10489     LSR W9, W9
000C5A  D38408     RRC W8, W8
000C5C  E80000     INC W0, W0
000C5E  3AFFFA     BRA NZ, subnormal
000C60  200071     MOV #0x7, W1
000C62  640061     AND W8, #0x1, W0
000C64  700003     IOR W0, W3, W0
000C66  600002     AND W0, W2, W0
000C68  320009     BRA Z, packupandgo
000C6A  440461     ADD W8, #0x1, W8
000C6C  4C84E0     ADDC W9, #0x0, W9
000C6E  A58809     BTST.Z W9, W1
000C70  320005     BRA Z, packupandgo
000C72  E8058B     INC W11, W11
000C74  E10868     CP W1, #8
000C76  3A0002     BRA NZ, packupandgo
000C78  D10489     LSR W9, W9
000C7A  D38408     RRC W8, W8
000C7C  200FF2     MOV #0xFF, W2
000C7E  E15802     CP W11, W2
000C80  3D0005     BRA GE, overflow
000C82  DD5DC7     SL W11, #7, W11
000C84  B207F9     AND #0x7F, W9
000C86  758089     IOR W11, W9, W1
000C88  780008     MOV W8, W0
000C8A  060000     RETURN
000C8C  27F80B     MOV #0x7F80, W11
000C8E  78008B     MOV W11, W1
000C90  050000     RETLW #0x0, W0
---  /home/xc16/release-builds/build_20230327/src/libm/src/floatundisf.s  -------------------------------
000BE8  BE9F88     MOV.D W8, [W15++]
000BEA  BE9F8A     MOV.D W10, [W15++]
000BEC  708200     IOR W1, W0, W4
000BEE  710204     IOR W2, W4, W4
000BF0  718204     IOR W3, W4, W4
000BF2  320026     BRA Z, return0
000BF4  BE0400     MOV.D W0, W8
000BF6  BE0002     MOV.D W2, W0
000BF8  B81160     MUL.UU W2, #0x0, W2
000BFA  20096B     MOV #0x96, W11
000BFC  200295     MOV #0x29, W5
000BFE  CF8201     FF1L W1, W4
000C00  39000A     BRA NC, fixshift
000C02  B14105     SUB.B #0x10, W5
000C04  CF8200     FF1L W0, W4
000C06  390007     BRA NC, fixshift
000C08  B14105     SUB.B #0x10, W5
000C0A  CF8209     FF1L W9, W4
000C0C  390004     BRA NC, fixshift
000C0E  B14105     SUB.B #0x10, W5
000C10  CF8208     FF1L W8, W4
000C12  390001     BRA NC, fixshift
000C14  B14105     SUB.B #0x10, W5
000C16  524205     SUB.B W4, W5, W4
000C18  320012     BRA Z, round
000C1A  3B000A     BRA NN, shiftleft
000C1C  718182     IOR W3, W2, W3
000C1E  640161     AND W8, #0x1, W2
000C20  D10081     LSR W1, W1
000C22  D38000     RRC W0, W0
000C24  D38489     RRC W9, W9
000C26  D38408     RRC W8, W8
000C28  E8058B     INC W11, W11
000C2A  E84204     INC.B W4, W4
000C2C  3AFFF7     BRA NZ, shiftright
000C2E  370007     BRA round
000C30  440408     ADD W8, W8, W8
000C32  4C8489     ADDC W9, W9, W9
000C34  480000     ADDC W0, W0, W0
000C36  488081     ADDC W1, W1, W1
000C38  E9058B     DEC W11, W11
000C3A  E94204     DEC.B W4, W4
000C3C  3AFFF9     BRA NZ, shiftleft
000C3E  070003     RCALL __fpack
000C40  BE054F     MOV.D [--W15], W10
000C42  BE044F     MOV.D [--W15], W8
000C44  060000     RETURN
---  /home/xc16/release-builds/build_20230327/src/libm/src/floatsisf.s  ---------------------------------
0004EE  DE894F     ASR W1, #15, W2
0004F0  780182     MOV W2, W3
0004F2  37036A     BRA ___floatdisf
---  /home/xc16/release-builds/build_20230327/src/libm/src/floatdisf.s  ---------------------------------
000BC8  781F88     MOV W8, [W15++]
000BCA  780403     MOV W3, W8
000BCC  E00003     CP0 W3
000BCE  3D0007     BRA GE, notspecial
000BD0  100060     SUBR W0, #0x0, W0
000BD2  1880E0     SUBBR W1, #0x0, W1
000BD4  190160     SUBBR W2, #0x0, W2
000BD6  1981E0     SUBBR W3, #0x0, W3
000BD8  3B0002     BRA NN, notspecial
000BDA  2DF001     MOV #0xDF00, W1
000BDC  370003     BRA return0
000BDE  070004     RCALL ___floatundisf
000BE0  A7F008     BTSC W8, #15
000BE2  A0F001     BSET W1, #15
000BE4  78044F     MOV [--W15], W8
000BE6  060000     RETURN
---  /home/xc16/release-builds/build_20230327/src/libm/src/fixsfsi.s  -----------------------------------
0004AC  BE0100     MOV.D W0, W2
0004AE  070022     RCALL __funpack
0004B0  A77004     BTSC W4, #7
0004B2  A1F003     BCLR W3, #15
0004B4  B10965     SUB #0x96, W5
0004B6  320016     BRA Z, setsign
0004B8  35000D     BRA LT, shiftright
0004BA  E12868     CP W5, #8
0004BC  350006     BRA LT, shiftleft
0004BE  2FFFF0     MOV #0xFFFF, W0
0004C0  27FFF1     MOV #0x7FFF, W1
0004C2  E00003     CP0 W3
0004C4  3B0013     BRA NN, exit
0004C6  280001     MOV #0x8000, W1
0004C8  050000     RETLW #0x0, W0
0004CA  400000     ADD W0, W0, W0
0004CC  488081     ADDC W1, W1, W1
0004CE  E90285     DEC W5, W5
0004D0  3AFFFC     BRA NZ, shiftleft
0004D2  370008     BRA setsign
0004D4  428FF8     ADD W5, #0x18, [W15]
0004D6  3C0002     BRA GT, shiftrightloop
0004D8  EB0080     CLR W1
0004DA  050000     RETLW #0x0, W0
0004DC  D10081     LSR W1, W1
0004DE  D38000     RRC W0, W0
0004E0  E80285     INC W5, W5
0004E2  3AFFFC     BRA NZ, shiftrightloop
0004E4  E00003     CP0 W3
0004E6  3B0002     BRA NN, exit
0004E8  100060     SUBR W0, #0x0, W0
0004EA  1880E0     SUBBR W1, #0x0, W1
0004EC  060000     RETURN
---  /home/xc16/release-builds/build_20230327/src/libm/src/fgtge.s  -------------------------------------
000D38  2FFFF4     MOV #0xFFFF, W4
000D3A  370000     BRA __fcompare
---  /home/xc16/release-builds/build_20230327/src/libm/src/feqltle.s  -----------------------------------
000D34  200014     MOV #0x1, W4
000D36  370002     BRA __fcompare
---  /home/xc16/release-builds/build_20230327/src/libm/src/fcompare.s  ----------------------------------
000D3C  BE9F88     MOV.D W8, [W15++]
000D3E  BE9F8A     MOV.D W10, [W15++]
000D40  781F84     MOV W4, [W15++]
000D42  070017     RCALL __funpack2
000D44  78004F     MOV [--W15], W0
000D46  330011     BRA N, exit
000D48  2FFFF0     MOV #0xFFFF, W0
000D4A  6C8F83     XOR W9, W3, [W15]
000D4C  3B0006     BRA NN, comparemag
000D4E  650504     AND W10, W4, W10
000D50  A7000A     BTSC W10, #0
000D52  370008     BRA returnEqual
000D54  A6F009     BTSS W9, #15
000D56  200010     MOV #0x1, W0
000D58  370008     BRA exit
000D5A  540F82     SUB W8, W2, [W15]
000D5C  5C8F83     SUBB W9, W3, [W15]
000D5E  390003     BRA NC, adjust
000D60  200010     MOV #0x1, W0
000D62  3E0001     BRA GTU, adjust
000D64  200000     MOV #0x0, W0
000D66  A7F009     BTSC W9, #15
000D68  EA0000     NEG W0, W0
000D6A  BE054F     MOV.D [--W15], W10
000D6C  BE044F     MOV.D [--W15], W8
000D6E  E00000     CP0 W0
000D70  060000     RETURN
